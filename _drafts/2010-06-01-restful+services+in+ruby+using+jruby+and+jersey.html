---
layout: post
title: Restful Services in Ruby using JRuby and Jersey
date: '2010-06-01T16:09:00.001-07:00'
author: headius
tags: 
modified_time: '2011-01-25T21:44:30.481-08:00'
blogger_id: tag:blogger.com,1999:blog-4704664917418794835.post-7672787497289836408
---

There's lots of ways to present RESTful web services these days, and REST has obviously become the new "it's IPC no it's not" hotness. And of course Rubyists have been helping to lead the way, building restfulness into just about everything they write. Rails itself is built around REST, with most controllers doubling as RESTful interfaces, and it even provides extra tools to help you transparently make RESTful calls from your application. If you're doing RESTful services for a typical Ruby application, Rails is the way to go (and even if you're not using Ruby in general...you should be considering JRuby + Rails).<br /><br />In the Java world the options aren't quite as clear, but one API has at least attempted to standardize the idea of doing RESTful services on the Java platform: JSR-311, otherwise known as JAX-RS.<br /><br />JAX-RS in theory makes it easy for you to simply mark up a piece of Java code with annotations and have it automatically be presented as a RESTful service. Of the available options, it may be the simplest, quickest way to get a Java-based service published and running.<br /><br />So I figured I'd try to use it from JRuby, and when doing it in Ruby it's actually surprisingly clean, even compared to Ruby options.<br /><br /><span style="font-weight:bold;">The Service</span><br /><br />I followed the Jersey <a href="https://jersey.dev.java.net/source/browse/*checkout*/jersey/tags/jersey-1.0.3/jersey/getting-started.html">Getting Started</a> tutorial using Ruby for everything (and not using Maven in this case).<br /><br />My version of their HelloWorldResource looks like this in Ruby:<br /><pre>require 'java'java_import 'javax.ws.rs.Path'<br />java_import 'javax.ws.rs.GET'<br />java_import 'javax.ws.rs.Produces'<br /><br />java_package 'com.headius.demo.jersey'<br />java_annotation 'Path("/helloworld")'<br />class HelloWorld<br />  java_annotation 'GET'<br />  java_annotation 'Produces("text/plain")'<br />  def cliched_message<br />    "Hello World"<br />  end<br />end</pre><br />Notice that we're using the new features in JRuby 1.5 for producing "real" Java classes: java_package to specify a target package for the Java class, java_annotation to specify class and method annotations.<br /><br />We compile it using jrubyc from JRuby 1.5 like this:<br /><pre>~/projects/jruby ➔ jrubyc -c ../jersey-archive-1.2/lib/jsr311-api-1.1.1.jar --javac restful_service.rb Generating Java class HelloWorld to /Users/headius/projects/jruby/com/headius/demo/jersey/HelloWorld.java<br />javac  -d /Users/headius/projects/jruby -cp /Users/headius/projects/jruby/lib/jruby.jar:../jersey-archive-1.2/lib/jsr311-api-1.1.1.jar /Users/headius/projects/jruby/com/headius/demo/jersey/HelloWorld.java</pre><br />The new --java(c) flags in jrubyc examine your source for any classes, spitting out .java source for each one in turn. Along the way, if you have marked it up with signatures, annotations, imports, and so on, it will emit those into the Java source as well. If you specify --javac (as opposed to --java), it will also compile the resulting sources for you with jruby and your user-specified jars in the classpath, as I've done here.<br /><br />The result looks like this to Java:<br /><pre>~/projects/jruby ➔ javap com.headius.demo.jersey.HelloWorld<br />Compiled from "HelloWorld.java"<br />public class com.headius.demo.jersey.HelloWorld extends org.jruby.RubyObject{<br />    public static org.jruby.runtime.builtin.IRubyObject __allocate__(org.jruby.Ruby, org.jruby.RubyClass);<br />    public com.headius.demo.jersey.HelloWorld();<br />    public java.lang.Object cliched_message();<br />    static {};<br />}</pre><br />Under the covers, this class will load in the source of our restful_service.rb file and wire up all the Ruby and Java pieces so that both sides see HelloWorld as the in-memory representation of the Ruby HelloWorld class. Method calls are dispatched to the Ruby code, constructors dispatch to initialize, and so on. It's truly living in both worlds.<br /><br />With the service in hand, we now need a server script to start it up.<br /><br /><span style="font-weight:bold;">The Server Script</span><br /><br />Continuing with the tutorial, I've taken their simple Java-based server script and ported it directly to Ruby:<br /><pre>require 'java'<br />java_import com.sun.jersey.api.container.grizzly.GrizzlyWebContainerFactory<br /><br />base_uri = "http://localhost:9998/"<br />init_params = {<br />  "com.sun.jersey.config.property.packages" => "com.headius.demo.jersey"<br />}<br /><br />puts "Starting grizzly"<br />thread_selector = GrizzlyWebContainerFactory.create(<br />    base_uri, init_params.to_java)<br /><br />puts <<EOS<br />Jersey app started with WADL available at #{base_uri}application.wadl<br />Try out #{base_uri}helloworld<br />Hit enter to stop it...<br />EOS<br /><br />gets<br /><br />thread_selector.stop_endpoint<br /><br />exit(0)</pre><br />It's somewhat cleaner and shorter, but it wasn't particularly large to begin with. At any rate, it shows how simple it is to launch a Grizzly server and how nice annotation-based APIs can be for auto-configuring our JAX-RS service.<br /><br /><span style="font-weight:bold;">The CLASSPATH</span><br /><br />Ahh CLASSPATH. You are so maligned when all you hope to do is make it explicit where libraries are coming from. The world should learn from your successes and your failures.<br /><br />There's five jars required for this Jersey example to run. I've tossed them into my CLASSPATH env var, but you're free to do it however you like<br /><pre>jersey-core-1.2.jar<br />jersey-server-1.2.jar<br />jsr311-api-1.1.1.jar<br />asm-3.1.jar<br />grizzly-servlet-webserver-1.9.9.jar</pre><br />The first four are available in the <a href="http://download.java.net/maven/2/com/sun/jersey/jersey-archive/1.2/jersey-archive-1.2.zip">jersey-archive download</a>, and you can fetch the <a href="http://download.java.net/maven/2/com/sun/grizzly/grizzly-servlet-webserver/1.9.9/">Grizzly jar from Maven</a> or other places.<br /><br /><span style="font-weight:bold;">Testing It Out</span><br /><br />The lovely bit about this is that it's essentially a four-step process to do the entire thing: write and compile the service, write the server script, set up CLASSPATH, and run the server. Here's the server output, finding my HelloWorld service right where it should:<br /><pre>~/projects/jruby ➔ jruby main.rb<br />Starting grizzly<br />Jersey app started with WADL available at http://localhost:9998/application.wadl<br />Try out http://localhost:9998/helloworld<br />Hit enter to stop it...<br />Jun 1, 2010 6:36:55 PM com.sun.jersey.api.core.PackagesResourceConfig init<br />INFO: Scanning for root resource and provider classes in the packages:<br />  com.headius.demo.jersey<br />Jun 1, 2010 6:36:55 PM com.sun.jersey.api.core.ScanningResourceConfig logClasses<br />INFO: Root resource classes found:<br />  class com.headius.demo.jersey.HelloWorld<br />Jun 1, 2010 6:36:55 PM com.sun.jersey.api.core.ScanningResourceConfig init<br />INFO: No provider classes found.<br />Jun 1, 2010 6:36:55 PM com.sun.jersey.server.impl.application.WebApplicationImpl initiate<br />INFO: Initiating Jersey application, version 'Jersey: 1.2 05/07/2010 02:04 PM'</pre><br />And perhaps the most anti-climactic climax ever, curling our newly-deployed service:<br /><pre>~ ➔ curl http://localhost:9998/helloworld<br />Hello World</pre><br />It works!<br /><br /><span style="font-weight:bold;">What We've Learned</span><br /><br />This was a simple example, but we demonstrated several things:<br /><br />JRuby's new jrubyc --java(c) support for generating "real" Java classes<br />Tagging a Ruby class with Java annotations, so it can be seen by a Java framework<br />Booting a Grizzly server from Ruby code<br />Implementing a JAX-RS service with Jersey in Ruby code<br /><br />Do you have any examples of other nice annotation-based APIs we could test out with JRuby?