---
layout: post
title: Fear of Public Speaking
date: '2006-12-30T10:56:00.000-08:00'
author: headius
tags: 
modified_time: '2011-01-25T21:44:33.412-08:00'
blogger_id: tag:blogger.com,1999:blog-4704664917418794835.post-9148680679803480626
---

I've been having nightmares lately about public speaking. While I was in Europe, I had a dream that I couldn't work on JRuby unless it was done in the context of a presentation. In other words, I had to do everything such that it could be presented the same day. A few days ago I dreamt I had shown up for a speaking engagement without a laptop. Last night, the horror of realizing 5 minutes before my presentation that my slides weren't ready and my demos had been neither pre-tested nor primed for show. *Shudder*<br /><br />I think this all means one of two things: I've been presenting too often; or public speaking has become a big part of what I do. So this morning I figured a review of past speaking engagements and a preview of things to come would be warranted.<br /><br /><span style="font-weight: bold;">RubyConf 2005</span><br /><br />This is where it all started. I had been on the JRuby team for about a year, and had very recently launched into a series of more complicated changes to the codebase. I had rewritten the interpreter engine, aiming for a pure stackless interpreter that could support continuations, green threads, and tail-call optimization. I was rapidly learning about the internals of both Ruby and JRuby and gaining a better understanding of the challenges facing both.<br /><br />The presentation was given to a couple hundred people in San Diego, and garnered more than a few yawns. At the time nobody was particularly interested in JRuby, and even with my too-lofty goals and fancy 100k recursive fib (tail-called, naturally), JRuby was still Java, and I was in a room full of Java expats.<br /><br />There were a few people who recognized the potential, but the presentation largely just introduced people to the 4-year-old JRuby and gave them some clue what might happen in the next year.<br /><br />So, of the goals presented for JRuby, which ones have been accomplished, which have fallen by the wayside, and what unexpected milestones did we reach?<br /><ul><li>Stackless Interpreter - The original "stackless" interpreter got close to being fully stackless a number of times, but the overhead of that interpreter design started to become the primary bottleneck in JRuby. I wrote a much simpler stack-heavy design this past October to answer performance questions, though we still plan to revisit a stackless design once the rest of JRuby can better support it. In the long term, however, this goal is greatly complicated by Java's inability to manipulate call stacks; if we want to use Java code we either have to trampoline back out or use bytecode post-processing to avoid deepening the stack.</li><li>Continuations - If you missed it, a great furor arose over whether continuations would be in Ruby 2.0 or not. At first, matz and ko1 appeared to say no. Then the answer appeared to be yes. Then, various answers in the middle. As it stands now, it's still questionable whether continuations will survive, especially considering the overhead required to support them and the numerous other techniques available for accomplishing the same goals. Given the poor penetration of continuations even among Ruby 1.8-compatible applications and their questionable future, we have opted for now to forgo implementing them for now. Also, since they depend on a stackless interpreter and stackless Java calls, they'll have to wait until both of those are feasible.</li><li>Tail-call Optimization - Another feature that depends on a stackless design, we have not tackled tail-calls for now. It would come along with the other stackless features, if we choose to go that route at some point.</li><li><br /></li></ul>