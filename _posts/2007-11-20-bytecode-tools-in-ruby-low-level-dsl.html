---
layout: post
title: 'Bytecode Tools in Ruby: A Low-level DSL'
date: '2007-11-20T19:26:00.000-08:00'
author: headius
tags: 
modified_time: '2011-01-25T21:44:32.279-08:00'
blogger_id: tag:blogger.com,1999:blog-4704664917418794835.post-234510508419467475
blogger_orig_url: http://blog.headius.com/2007/11/bytecode-tools-in-ruby-low-level-dsl.html
---

I've been toying with the idea of rewriting the JRuby compiler in Ruby, or at least writing the appropriate plumbing that would allow someone to do something similar. Migrating the JRuby compiler may or may not be worth it, since the existing Java compiler is basically done and working well, and a conversion would be sure to introduce bugs here and there. But it would certainly be a show of faith to give it a try.<br /><br />As part of this effort, I've built up some basic utility code and a simple JVM bytecode builder that could act as the lowest level of such a compiler. I'm looking for input on the syntax at this point, while I take a break from it to explore JRuby Java integration improvements I think should be done before 1.1.<br /><br />So here's the Ruby source of the builder, as contained within a test case:<br /><pre>require 'test/unit'<br />require 'compiler/builder'<br />require 'compiler/signature'<br /><br />class TestBuilder &lt; Test::Unit::TestCase<br />import java.lang.String<br />import java.util.ArrayList<br />import java.lang.Void<br />import java.lang.Object<br />import java.lang.Boolean<br /><br />include Compiler::Signature<br /><br />def test_class_builder<br />  cb = Compiler::ClassBuilder.build("MyClass", "MyClass.java") do<br />    field :list, ArrayList<br />  <br />    constructor(String, ArrayList) do<br />      aload 0<br />      invokespecial Object, "&lt;init&gt;", Void::TYPE<br />      aload 0<br />      aload 1<br />      aload 2<br />      invokevirtual this, :bar, [ArrayList, String, ArrayList]<br />      aload 0<br />      swap<br />      putfield this, :list, ArrayList<br />      returnvoid<br />    end<br />  <br />    static_method(:foo, this, String) do<br />      new this<br />      dup<br />      aload 0<br />      new ArrayList<br />      dup<br />      invokespecial ArrayList, "&lt;init&gt;", Void::TYPE<br />      invokespecial this, "&lt;init&gt;", [Void::TYPE, String, ArrayList]<br />      areturn<br />    end<br />  <br />    method(:bar, ArrayList, String, ArrayList) do<br />      aload 1<br />      invokevirtual(String, :toLowerCase, String)<br />      aload 2<br />      swap<br />      invokevirtual(ArrayList, :add, [Boolean::TYPE, Object])<br />      aload 2<br />      areturn<br />    end<br />  <br />    method(:getList, ArrayList) do<br />      aload 0<br />      getfield this, :list, ArrayList<br />      areturn<br />    end<br />  <br />    static_method(:main, Void::TYPE, String[]) do<br />      aload 0<br />      ldc_int 0<br />      aaload<br />      invokestatic this, :foo, [this, String]<br />      invokevirtual this, :getList, ArrayList<br />      aprintln<br />      returnvoid<br />    end<br />  end<br /><br />  cb.write("MyClass.class")<br />end<br />end</pre><br />For those of you who don't speak bytecode, here's roughly the Java code that this would produce:<br /><pre>import java.util.ArrayList;<br /><br />public class MyClass {<br />  public ArrayList list;<br /><br />  public MyClass(String a, ArrayList b) {<br />      list = bar(a, b);<br />  }<br /><br />  public static MyClass foo(String a) {<br />      return new MyClass(a, new ArrayList());<br />  }<br /><br />  public ArrayList bar(String a, ArrayList b) {<br />      b.add(a.toLowerCase());<br />      return b;<br />  }<br /><br />  public ArrayList getList() {<br />      return list;<br />  }<br /><br />  public static void main(String[] args) {<br />      System.out.println(foo(args[0]).getList());<br />  }<br />}</pre><br />The general idea is that fairly clean-looking Ruby code can be used to generate real Java classes, providing a readable base for code generation tools like compilers.<br /><br />There's a couple things to notice here:<br /><ul><li>Everything is public. I have not wired in visibility and other modifiers mainly because it starts to look cluttered no matter how I try. Suggestions are welcome.</li><li>The bytecode, while clean looking, is pretty raw. This interface also doesn't save you from yourself; if you're not ordering your bytecodes right, you'll end up with an unverifiable class file.</li><li>It's not apparent just from looking at the code which types specified are return values and which are argument values. Something more explicit could be useful here.</li></ul>I'd like to continue this work. The above code, run against JRuby trunk and the lib/ruby/site_ruby/1.8/compiler library I'm working on, will produce a working MyClass class file:<br /><pre>~/NetBeansProjects/jruby $ jruby test/compiler/test_builder.rb<br />Loaded suite test/compiler/test_builder<br />Started<br />.<br />Finished in 0.096 seconds.<br /><br />1 tests, 0 assertions, 0 failures, 0 errors<br />~/NetBeansProjects/jruby $ java -cp . MyClass foo<br />[foo]</pre><br />So it's actually emitting the appropriate bytecode for this class.<br /><br />Comments? Thoughts for improvement?