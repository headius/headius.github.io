---
layout: post
title: Converting Groovy to Ruby
date: '2008-04-17T15:35:00.000-07:00'
author: headius
tags: 
modified_time: '2011-01-25T21:44:31.716-08:00'
blogger_id: tag:blogger.com,1999:blog-4704664917418794835.post-1179131164432670631
blogger_orig_url: http://blog.headius.com/2008/04/converting-groovy-to-ruby.html
---

In <a href="http://www.glenstampoultzis.net/blog/?p=61">this post</a>, Glen Stampoultzis posts a very interesting and clever sequence of steps by which he converts a piece of Java code into idiomatic Groovy code. I thought it was a nice article, so I'll do a very short spin on it: taking Glen's final Groovy code and converting it into idiomatic Ruby.<br /><br />(I'll probably get my pants flamed off by you-know-who, but hey, it's a slow Thursday afternoon.)<br /><br />Glen's code, an algorithm for finding all n-length subsequences in a given array, ends up here:<br /><pre>def subn(n, list) {<br />    if (n == 0) return [[]];<br />    if (list.isEmpty()) return [];<br /><br />    def remainder = list.subList(1, list.size());<br />    return subn(n-1, remainder).collect() { [list.get(0)] + it } + subn(n, remainder);<br />}</pre>(I had to make some edits because his code didn't appear to format right; I don't claim this code is 100% correct in this state.) Admittedly it's a very nice reduction from the original Java code. As Glen correctly surmises, it's largely due to those super-nice closures we get from Groovy. My first step is to make a few minor changes to make it run correctly in Ruby:<br /><pre>def subn(n, list)<br />    return [[]] if (n == 0);<br />    return [] if (list.empty?());<br /><br />    remainder = list.slice(1, list.size());<br />    return subn(n-1, remainder).collect() {|it| [list.at(0)] + it } + subn(n, remainder);<br />end</pre>The most notable changes here are flopping the statement-modifying conditionals on the first two returns and adding an "it" parameter to the collect block. Oh, there's also the "empty?" method. But largely it looks like pretty much the same code. The next obvious step is to remove things that aren't needed in Ruby.<br /><pre>def subn(n, list)<br />    return [[]] if n == 0<br />    return [] if list.empty?<br /><br />    remainder = list.slice(1, list.size)<br />    return subn(n-1, remainder).collect {|it| [list.at(0)] + it } + subn(n, remainder)<br />end</pre>Mostly just removing some parens that are unnecessary (and distracting, for me) as well as line-terminating semicolons. Note that Groovy also can omit line-terminating semicolons. I think it's a matter of taste.<br /><pre>def subn(n, list)<br />    return [[]] if n == 0<br />    return [] if list.empty?<br /><br />    remainder = list[1..-1]<br />    subn(n-1, remainder).collect {|it| [list[0]] + it } + subn(n, remainder)<br />end</pre>Now we've eliminated the last "return" statement and made the list accesses use the array-referencing "[]" method...in the first case with a more idiomatic range of values rather than two parameters. Again, a matter of taste I suppose; two arguments works just fine. So that brings us mostly to the end of converting from the original Groovy code into Ruby. The new version is as readable as the original, but shorter by several characters. And of course this is my biased opinion, but it reads nicer too. I'm sure that will bring about all sorts of flaming in itself.<br /><br />At any rate, my point in this is certainly not to start a flame war about which version is better. My point is that the Groovy and Ruby versions are still largely the same. If you can learn to produce the Groovy end result, you can just as easily learn to produce the Ruby end result. So if you've stuck with Java because you're worried you can't learn Ruby, or you don't think Ruby is enough like Java...don't be scared! A whole Rubylicious world awaits you :)<br /><br />(Oh, and for you Rubyists out there...feel free to post your own improvements in the comments. I didn't want to change the original flow of the code, but I know it can be golfed down a lot more.)