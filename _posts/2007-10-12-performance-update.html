---
layout: post
title: Performance Update
date: '2007-10-12T00:00:00.000-07:00'
author: headius
tags: 
modified_time: '2011-01-25T21:44:32.472-08:00'
blogger_id: tag:blogger.com,1999:blog-4704664917418794835.post-1338293068161948198
blogger_orig_url: http://blog.headius.com/2007/10/performance-update.html
---

As some of you may know, I've been busily migrating all method binding to use Java annotations. The main reasons for this are to simplify binding and to provide end-to-end metadata that can be used for optimizing methods. It has enabled using a single binding generator for 90% of methods in the system (and increasing). And today that has enabled making some impressive perf improvements.<br /><br />The method binding ends up looking like this:<br /><pre>@JRubyMethod(name = "[]", name2 = "slice",<br />   required = 1, optional = 1)<br />public IRubyObject aref(IRubyObject[] args) {<br />...</pre><br />This binds the <span style="font-style: italic;">aref</span> Java method to the two Ruby method names <span style="font-style: italic;">[]</span> and <span style="font-style: italic;">slice</span> and enforces a minimum of one argument and a maximum of two. And it does this all automatically; no manual arity checking or method binding is necessary. Neat. But that's not the coolest result of the migration.<br /><br />The first big step I took today was migrating all annotation-based binding to directly generate unique DynamicMethod subclasses rather than unique Callback subclasses that would then be wrapped in a generic DynamicMethod implementation. This moves generated code closer to the actual calls.<br /><br />The second step was to completely disable <a href="http://citeseer.ist.psu.edu/driesen93selector.html">STI dispatch</a>. STI, we shall miss you.<br /><br />So, benchmarks. Of course fibonacci numbers are indicative of only a very narrow range of performance, but I think they're a good indicator of where general performance will go in the future, as we're able to expand these optimizations to a wider range of methods.<br /><br />JRuby before the changes:<br /><pre>$ jruby -J-server -O bench_fib_recursive.rb<br />1.039000   0.000000   1.039000 (  1.039000)<br />1.182000   0.000000   1.182000 (  1.182000)<br />1.201000   0.000000   1.201000 (  1.201000)<br />1.197000   0.000000   1.197000 (  1.197000)<br />1.208000   0.000000   1.208000 (  1.208000)<br />1.202000   0.000000   1.202000 (  1.202000)<br />1.187000   0.000000   1.187000 (  1.187000)<br />1.188000   0.000000   1.188000 (  1.188000)</pre><br />JRuby after:<br /><pre>$ jruby -J-server -O bench_fib_recursive.rb<br />0.864000   0.000000   0.864000 (  0.863000)<br />0.640000   0.000000   0.640000 (  0.640000)<br />0.637000   0.000000   0.637000 (  0.637000)<br />0.637000   0.000000   0.637000 (  0.637000)<br />0.642000   0.000000   0.642000 (  0.642000)<br />0.643000   0.000000   0.643000 (  0.643000)<br />0.652000   0.000000   0.652000 (  0.652000)<br />0.637000   0.000000   0.637000 (  0.637000)</pre><br />This is probably the largest performance boost since the early days of the compiler, and it's by far the fastest fib has ever run. Here's MRI (Ruby 1.8) and YARV (Ruby 1.9) numbers for comparison:<br /><br />MRI:<br /><pre>$ ruby bench_fib_recursive.rb<br />1.760000   0.010000   1.770000 (  1.813867)<br />1.750000   0.010000   1.760000 (  1.827066)<br />1.760000   0.000000   1.760000 (  1.796172)<br />1.760000   0.010000   1.770000 (  1.822739)<br />1.740000   0.000000   1.740000 (  1.800645)<br />1.750000   0.010000   1.760000 (  1.751270)<br />1.750000   0.000000   1.750000 (  1.778388)<br />1.740000   0.000000   1.740000 (  1.755024)</pre><br />And YARV:<br /><pre>$ ./ruby -I lib bench_fib_recursive.rb<br />0.390000   0.000000   0.390000 (  0.398399)<br />0.390000   0.000000   0.390000 (  0.412120)<br />0.400000   0.010000   0.410000 (  0.424013)<br />0.400000   0.000000   0.400000 (  0.415217)<br />0.400000   0.000000   0.400000 (  0.409039)<br />0.390000   0.000000   0.390000 (  0.415853)<br />0.400000   0.000000   0.400000 (  0.415201)<br />0.400000   0.000000   0.400000 (  0.504051)</pre><br />What I think is really awesome is that I'm comfortable showing YARV's numbers, since we're getting so close--and YARV has a bunch of additional integer math optimizations we don't currently support and thought we'd never be able to compete with. Well, I guess we can.<br /><br />However a more reasonable benchmark is the "pentomino" benchmark in the YARV suite. We've always been slower than MRI...much slower some time ago when nothing compiled. But times they are a-changin'. Here's JRuby before the changes:<br /><pre>$ time jruby -J-server -O sbench/bm_app_pentomino.rb<br /><br />real    1m50.463s<br />user    1m49.990s<br />sys     0m1.131s</pre><br />And after:<br /><pre>$ time jruby -J-server -O bench/bm_app_pentomino.rb<br /><br />real    1m25.906s<br />user    1m26.393s<br />sys     0m0.946s</pre><br />MRI:<br /><pre>$ time ruby test/bench/yarv/bm_app_pentomino.rb<br /><br />real    1m47.635s<br />user    1m47.287s<br />sys     0m0.138s</pre><br />And YARV:<br /><pre>$ time ./ruby -I lib bench/bm_app_pentomino.rb<br /><br />real    0m49.733s<br />user    0m49.543s<br />sys     0m0.104s</pre><br />Again, keep in mind that YARV is optimized around these benchmarks, so it's not surprising it would still be faster. But with these recent changes--general-purpose changes that are not targeted at any specific benchmark--we're now less than 2x slower.<br /><br />My confidence has been wholly restored.