---
layout: post
title: 'Ruby Compiler Fun: AOT and JIT Compilation'
date: '2007-01-12T00:23:00.000-08:00'
author: headius
tags: 
modified_time: '2011-01-25T21:44:33.293-08:00'
blogger_id: tag:blogger.com,1999:blog-4704664917418794835.post-8430926544148624781
blogger_orig_url: http://blog.headius.com/2007/01/ruby-compiler-fun-aot-and-jit.html
---

Who knew writing a compiler could be so much fun.<br /><br />I managed to accomplish two things tonight. It's late and I have a flight home tomorrow, so I'll be brief.<br /><br /><span style="font-weight: bold;">jrubyc: JRuby's Ahead-Of-Time (AOT) Compiler</span><br /><br />I have whipped together the very barest of command-line, ahead-of-time compilers, along with a simple script to invoke it.<br /><pre>~/NetBeansProjects/jruby $ jrubyc<br />Usage: jrubyc &lt;filename&gt; [&lt;dest&gt;]<br /></pre>It's mostly just a very thin wrapper around the existing compiler code, so it can only compile constructs it knows about. However, for really simple scripts without any unrecognized nodes, it works fine:<br /><pre>~/NetBeansProjects/jruby $ cat samples/fib.rb<br /># calculate Fibonacci(20)<br /># for benchmark<br />def fib(n)<br />if n&lt;2<br />  n<br />else<br />  fib(n-2)+fib(n-1)<br />end<br />end<br />print(fib(20), "\n")<br />~/NetBeansProjects/jruby $ jrubyc samples/fib.rb tmp<br />~/NetBeansProjects/jruby $ ls tmp/samples<br />fib$MultiStub0.class    fib.class<br /></pre>At the moment, two classes are generated; one is a class to hold the script entry points and the other is a stub class for all the actual blocks of code contained within the script (toplevel code, method code, etc). This will soon be a single class file, so pay the MultiStub no mind.<br /><br />We can then execute the script like you'd expect, specifying the JRuby and ASM jar files on the classpath:<br /><pre>~/NetBeansProjects/jruby $ export CLASSPATH=lib/jruby.jar:lib/asm-2.2.2.jar:tmp        <br />~/NetBeansProjects/jruby $ java samples/fib<br />6765<br /></pre>Huzzah! Compilation!<br /><br />Now of course, as I mentioned, this only compiles scripts containing constructs it knows about. If you try to compile a script it can't handle, you'll get an error:<br /><pre>~/NetBeansProjects/jruby $ jrubyc lib/ruby/1.8/singleton.rb<br />Error -- Not compileable: Can't compile node: ModuleNode[]<br /></pre>The compiler currently supports only literal fixnums, strings, and arrays, simple method definitions, while loops, if/else, and calls that don't involve blocks or splatted arguments. More will come as time progresses. The benefit of building the compiler piecemeal like this becomes more apparent in the next section...<br /><br /><span style="font-weight: bold;">JIT Compilation</span><br /><br />The current compiler only understands enough of Ruby to handle my experimentation and research. The compiler also does not output one-to-one Ruby-to-Java classes or even a single large method: it outputs a class containing a method for every semantically separate block of code in a given script. In Ruby's case, that means toplevel code, code found within the body of a class, and code found within the body of a method definition. By combining these two traits, we have everything necessary for a simple JIT.<br /><br />A JIT, or Just-In-Time compiler, performs its compilation at runtime, usually based on some gathered information about the executing code. HotSpot, for example, has an extensive array of optimizations it can perform on running code just by watching how it executes and eliminating unnecessary overhead. My vastly simpler JIT uses a much more basic metric: the number of times a method has been invoked.<br /><br />The actual compiler code is the same as that used for the AOT compiler, with one major difference. Instead of the generated code being dumped to a file for later execution, it's immediately loaded, instantiated, and snuggled away in the same location where interpreted code used to live. The logic goes like this:<br /><ol><li>A method is called. We'll name it "foo"</li><li>foo's code is written in Ruby, so it's just a sequence of AST nodes to be interpreted</li><li>we interpret foo's nodes, but each time we increment a counter. When the counter reaches some number (currently 50), the compiler kicks in</li><li>if the code can't be compiled, we continue to interpretation, but we set a flag and never try to compile again</li><li>if the code can be compiled, we save the generated code and use it for all future invocations</li></ol>Because the compiler can generate these small pieces of code, we're able to JIT Ruby code that was not compiled before execution began, gaining the benefits of a compiled platform without losing the flexibility of an agile script-based development model. It also means <span style="font-style: italic;">we can start benefiting from bytecode compilation even before the compiler is complete</span>.<br /><br />So how well does it perform? Very well, provided you don't go outside the narrow range of AST nodes the script supports:<br /><pre>~/NetBeansProjects/jruby $ cat test/bench/bench_fib_recursive.rb<br />require 'benchmark'<br /><br />def fib_ruby(n)<br />if n &lt; 2<br />  n<br />else<br />  fib_ruby(n - 2) + fib_ruby(n - 1)<br />end<br />end<br /><br />puts Benchmark.measure { fib_ruby(30) }<br />puts Benchmark.measure { fib_ruby(30) }<br /></pre>Here we have a fib benchmark script with a few nodes the compiler can't handle. For example, the blocks at the bottom of the script won't compile correctly at present. So it's a good candidate for the JIT.<br /><br />Once the JRuby JIT's been wired up, we can simply run the code as normal:<br /><pre>~/NetBeansProjects/jruby $ jruby test/bench/bench_fib_recursive.rb<br />compiled: Object.fib_ruby<br />2.877000   0.000000   2.877000 (  2.876000)<br />2.955000   0.000000   2.955000 (  2.955000)<br /></pre>You will notice the "compiled" logging output I currently have in the JIT. The only method hit hard enough to be compiled during this run was the fib_ruby method defined on the toplevel Object instance. Now this performance is drastically increased over the current trunk, largely due to compilation but also due to a faster dynamic method invocation algorithm we're experimenting with. And there's still a lot of optimization left to be done at both the compiler and runtime levels. But it's already a vast improvement over JRuby from even a month ago. Things are moving very quickly now.<br /><br />We also look better running under the Java 6 server VM. The "server" VM performs more aggressive optimizations of Java code than does the default "client" VM. Generally this is because the optimizations involved cause the server VM to start up a bit more slowly, since it waits longer and gathers more information before JITing. However in this case, the results are very impressive when we compare the JRuby JIT running under the Java 6 server VM against Ruby 1.8.5:<br /><pre>~/NetBeansProjects/jruby $ jruby SERVER test/bench/bench_fib_recursive.rb<br />compiled: Object.fib_ruby<br />1.645000   0.000000   1.645000 (  1.645000)<br />1.452000   0.000000   1.452000 (  1.453000)<br />~/NetBeansProjects/jruby $ ruby test/bench/bench_fib_recursive.rb<br />1.670000   0.000000   1.670000 (  1.677901)<br />1.660000   0.000000   1.660000 (  1.671957)<br /></pre>The future's looking pretty bright.<br /><br />None of this code is in trunk at the moment, but it should land fairly soon. The AOT compiler may come before the JIT, since it's minimally invasive and won't affect normal interpreted mode execution. Look for both to be available in JRuby proper within a week or two, and watch for the compiler itself move toward completion over the coming weeks.<span style="font-style: italic;"></span>