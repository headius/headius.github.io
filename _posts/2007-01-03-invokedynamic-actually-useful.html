---
layout: post
title: 'InvokeDynamic: Actually Useful?'
date: '2007-01-03T11:04:00.000-08:00'
author: headius
tags:
- jsr292
- ruby
- invokedynamic
- jvm
- java
modified_time: '2011-01-25T21:44:33.372-08:00'
blogger_id: tag:blogger.com,1999:blog-4704664917418794835.post-8199432609683935335
blogger_orig_url: http://blog.headius.com/2007/01/invokedynamic-actually-useful.html
---

Over time I've become less convinced that hotswappable classes would be an absolute requirement for the proposed <span style="font-family: courier new;">invokedynamic</span> bytecode to be useful, and more convinced that there's a number of ways a dynamic language like Ruby or Groovy could utilize the new bytecode. This post gives a little background on <span style="font-family: courier new;">invokedynamic</span> and attempts to summarize a few ideas off the top of my head.<br /><br />Many folks, myself included, have long held that the proposed <span style="font-family: courier new;">invokedynamic</span> bytecode would only be useful if coupled with hotswappable classes. Hotswapping is the mechanism by which we could alter class structure after definition and have existing instances of the class pick up those changes. It's true this would be required if we were to compile Ruby all the way to bytecode; since Ruby classes are always open, we need the ability to add and remove methods without destroying already-created instances. The argument goes that if <span style="font-family: courier new;">invokedynamic</span> requires a dynamically-invoked method to exist on a target receiver's type, then we would only ever be able to <span style="font-family: courier new;">invokedynamic</span> against compiled Ruby code if we could continue to alter those types when classes get re-opened.<br /><br />I do believe that hotswapping would be useful, but it's fraught with many really difficult problems. To begin with, there's Java's security model, whereby a class that's been loaded into the system *can not* be modified  in most typical security contexts. The JVM does have the ability to replace existing method definitions at runtime, but that's generally reserved for debugging purposes, and it doesn't allow adding or removing methods. It also does not currently have the ability to wholesale remove and replace a class that has live instances, and it's an open research question to even consider the ramifications of allowing such a thing.<br /><br />So what are the alternatives? Gilad Bracha proposed having the ability to attach methods dynamically to a given static class at runtime. This would perhaps be similar to the CLR's "dynamic methods". This idea perhaps has more merit...one issue not addressed by hotswappable classes is that even once we compile Ruby to bytecode, it's still dynamic and duck-typed. Would all methods accept Object and return Object? Is that useful? By specifically stating that some methods are dynamic and mutable (in the case of a Ruby class, likely all methods we've compiled), you effectively create the equivalent of hotswapping without breaking existing static types and their security semantics.<br /><br />But this is all research that could and perhaps should occur outside <span style="font-family: courier new;">invokedynamic</span>, and it all may or may not be related. So then, can <span style="font-family: courier new;">invokedynamic</span> be useful with these class-structure questions unanswered? What does <span style="font-family: courier new;">invokedynamic</span> mean?<br /><br />To me, <span style="font-family: courier new;">invokedynamic</span> means the ability to invoke a method without statically binding to a specific type, and perhaps additionally without specifying static types for the parameter list. For those that don't know, when generating method-call bytecodes for the JVM, you must always provide two things in addition to the method name: the class within which the method you're invoking lives and the precise parameter list of the method you want to call. And there's not much wiggle room there; if you're off on the target type or if the receiver you're calling against has not yet been cast to (or been determined to match) that type, kaboom. If your parameter list doesn't match one on the target type, kaboom. If your parameters haven't been confirmed as being compatible with that signature, kaboom. Perhaps you can see, then, why writing a compiler for the JVM is such a complicated affair.<br /><br />So there's potential for <span style="font-family: courier new;">invokedynamic</span> to make even static compilation easier. Without the need to specify all those types, we can defer that compile-time magic to the VM, if we so choose. We don't have to dig around for the exact signature we want or the exact target type. Given a receiver object, a method name, and a bundle of parameter objects, <span style="font-family: courier new;">invokedynamic</span> should "do the right thing."<br /><br />Now we start to see where this could be useful. Any dynamic language on the JVM is going to be most interesting in the context of the platform's available libraries. Ruby is great on its own, and there's certainly an entire (potentially large) market segment that's interested in JRuby purely as an alternative Ruby runtime. But the larger market, and the more intriguing application of JRuby, is as a language to tie the thousands of available Java libraries together. And that requires calling Java code from Ruby and Ruby code from Java with as little complexity and overhead as possible.<br /><br />Enter <span style="font-family: courier new;">invokedynamic</span>.<br /><br />Now I've only recently started to see how <span style="font-family: courier new;">invokedynamic</span> could really be useful even without dynamic methods or hotswappable classes, so this list is bound to grow. I'd love to have all three features, of course, but here's a few areas that <span style="font-family: courier new;">invokedynamic</span> alone would be useful:<br /><ul><li>Our native implementations of Ruby methods can't really be tied to a specific concrete class, since we have to be able to rewire them at runtime if they're redefined. If <span style="font-family: courier new;">invokedynamic</span> came along with a mechanism for doing a Java-based "method_missing", whereby we could intercept dynamic calls to a given object and dispatch in our own way, we could make use of the bytecode without having hot-swappable classes.</li><li>It would also aid compilation and code generation. In my work on the prototype compiler, one of the biggest stumbling blocks is making sure I'm binding method calls to the appropriate target type. I must make sure the receiver of a method has been casted to the type I intend to bind to or Java complains about it. If there were a way to just say <span style="font-family: courier new;">invokedynamic</span>, omitting the target type, it would make compilation far simpler; and I don't believe HotSpot would have to do any additional work to make it fast, since it already has optimizations under the covers that are fairly type-agnostic.</li><li>To a lesser extent, <span style="font-family: courier new;">invokedynamic</span> could push the smarts of determining appropriate method signatures onto the VM. I would supply a series of parameters and a method name, and tell the VM to <span style="font-family: courier new;">invokedynamic</span>. The VM, in turn, would look at the params and name and select an appropriate method from the receiving object. This is in essence all that's needed for real duck typing to work.</li></ul>This last item calls out a perhaps surprising area that <span style="font-family: courier new;">invokedynamic</span> would be very useful: invoking Java code from a dynamic language.<br /><br />When calling Java code from Ruby, for example, all we really have to work with are two details: a method name and potentially an arity. We can do some inference based on the actual types of parameters, but there's a lot of magic and a number of heuristics involved. If there were a JVM-native mechanism for calling arbitrary methods on a given object, without having to statically bind to those methods, it would eliminate much of our Java integration layer.<br /><br />All told, I think <span style="font-family: courier new;">invokedynamic</span> would definitely be much more than a PR stunt, as some have claimed. It would eliminate one of the most difficult barriers to generating JVM bytecodes by allowing arbitrary method calls that aren't necessarily bound to specific types. I for one would vote yes, and I plan to throw my weight behind making <span style="font-family: courier new;">invokedynamic</span> do everything I need it to do...with or without hotswapping.