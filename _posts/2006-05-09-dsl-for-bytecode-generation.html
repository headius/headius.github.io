---
layout: post
title: A DSL for Bytecode Generation
date: '2006-05-09T14:10:00.000-07:00'
author: headius
tags: 
modified_time: '2011-01-25T21:44:34.715-08:00'
blogger_id: tag:blogger.com,1999:blog-4704664917418794835.post-333899701075689941
blogger_orig_url: http://blog.headius.com/2006/05/dsl-for-bytecode-generation.html
---

Having discovered the power and magic of bytecode generation, it occurred to me that none of the existing libraries have the subtle elegance that most code generation tasks really deserve. I believe there's a simple reason for this: they're written in Java. Some of them really try to make things easier, and perhaps come close to succeeding, but they're all still cumbersome, clunky, and very, very verbose.<br />

<br />I have been writing JRuby's compiler in pure ruby by calling out to a Java-based bytecode generation library. My initial attempts were fairly straightforward calls: push this, call that, pop the other. Very linear, very boring, very verbose, and not a great deal simpler than the equivalent Java code. It seemed such a shame to waste an expressive language like Ruby on such a menial task, I've decided to build a domain-specific language for Java bytecode generation.<br /><br />A short sample of what works today (basically the operations I needed for my test compiler):<br /><br /><span style="font-size:85%;"><span style="font-family:courier new;"><pre><span style="font-size:100%;">class_bytes = ClassBuilder.def_class :public, "FooClass" do |c|<br />  c.def_constructor :public do |con|<br />    con.call_super<br />    con.return_void<br />  end<br /><br />  c.def_method :public, :string, "myMethod", [:void], [:exception] do |m|<br />    m.call_this GenUtils.array_cls(:string), "getStringArr"<br />    m.call_this :string, "getMessage"<br />    m.return_top :ref<br />  end<br />  <br />  c.def_method :private, :string, "getMessage", [:void] do |m|<br />    m.construct_obj :stringbuffer, [:string] do |p|<br />      p.constant "Now I will say: "<br />    end<br />    <br />    m.call_method :stringbuffer, "append", :string, :stringbuffer do |p|<br />      p.constant "Hello CodeGen!"<br />    end<br />    m.call_method :string, "toString", :void, :stringbuffer<br />    m.return_top :ref<br />  end<br />  <br />  c.def_method :public, GenUtils.array_cls(:string), "getStringArr" do |m|<br />    m.construct_array :string, 5 do |p,i|<br />      p.constant "string \##{i}"<br />    end<br />    <br />    m.array_set 2, :string do |p|<br />      p.constant "replacement at index 2"<br />    end<br />    <br />    m.return_top :ref<br />  end<br />end</span><br /></pre></span><span style="font-size:100%;"><br />This approach has a number of advantages over others:</span><br /></span><ul><li>The structure of the generator is very similar to that of the generated code</li><li>Method parameters and array initializers (or the code to make them available) are logically associated with the eventual call or array they'll apply to</li><li>The builders maintain some internal state, and will be able to count stack depth, validate typing, automatically attempt casts, and automatically return the correct types</li><li>It's far easier to read</li><li>It's far more fun</li></ul>Some notes on the code above:<br /><ul><li>The param-building blocks (with |p| params) are in all cases optional. If omitted, method calls will assume you have prepared all params, array creation will create an empty array, and array sets will assume the value is already present on the stack.</li><li>The core bytecode operations (dup, etc) are still present and callable on the MethodBuilder m. This allows you to fall back to linear-style when necessary.</li><li>Various classes (perhaps eventually all classes) from java.lang are aliased as symbols like :string and :object. At the ClassBuilder level, it is also possible to "import" classes, as in <span style="font-size:100%;"><span style="font-family:courier new;">c.import "javax.swing.JFrame", :jframe</span></span> and use the aliased symbol throughout this generation (much like import in a .java file)</li><li>I'm looking for a better way to handle arrays. GenUtils is only used internally except for array types, and I'd like to hide it completely.<br /></li></ul><br />I'm tossing this working snippit out to the world for comments and critique...and perhaps as a little teaser of things to come. I'm planning to add a few more operations and port the early v1 compiler over to this soon...then both will develop together. I see this DSL/library as having huge potential for other projects that want a simple, elegant way to do bytecode generation.<br /><br />Thoughts? Comments?