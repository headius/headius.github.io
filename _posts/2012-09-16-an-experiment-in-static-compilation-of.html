---
layout: post
title: 'An experiment in static compilation of Ruby: FASTRUBY!'
date: '2012-09-16T21:36:00.000-07:00'
author: headius
tags: 
modified_time: '2012-09-16T21:46:42.441-07:00'
blogger_id: tag:blogger.com,1999:blog-4704664917418794835.post-4242550722639887199
blogger_orig_url: http://blog.headius.com/2012/09/an-experiment-in-static-compilation-of.html
---

<div dir="ltr" style="text-align: left;" trbidi="on">While at GoGaRuCo this weekend, I finally made good on an experiment I had been thinking about for a while: <a href="https://github.com/headius/fastruby">a static compiler for Ruby</a>. I thought I'd share it with you good people today.<br /><br />First we have a simple Ruby script with a class in it:<br /><br /><script src="https://gist.github.com/3735400.js?file=hello.rb"></script><br /><br />We compile it with fastruby, and it produces two .java source files: Hello.java and RObject.java.<br /><br />Hello.java implements the methods the Ruby class does in the script, and calls the same methods (with some mangling for invalid Java method names like _plus_ and _lt_).<br /><br /><script src="https://gist.github.com/3735400.js?file=Hello.java"></script><br /><br />RObject.java implements stubs for <u>all</u> method names seen in the script. As a result, all dynamic calls can just be virtual invocations against RObject. Classes that implement one of the methods will just work and the call is direct. Classes that don't implement the called method will raise an error.<br /><br /><script src="https://gist.github.com/3735400.js?file=RObject.java"></script><br /><br />RKernel comes with fastruby, and provides Kernel-level methods like "puts", plus methods for coercing to Java types like toBoolean and toString. It also caches some built-in singleton values like nil.<br /><br /><script src="https://gist.github.com/3735400.js?file=RKernel.java"></script><br /><br /><br />And there's a few other classes for this script to work. It should be easy to see how we could fill them out to do everything the equivalent Ruby classes do.<br /><div><br /></div><div><script src="https://gist.github.com/3735400.js?file=RFixnum.java"></script></div><div><br /></div><div><script src="https://gist.github.com/3735400.js?file=RString.java"></script></div><div><br /></div><div><script src="https://gist.github.com/3735400.js?file=RBoolean.java"></script></div><div><br /></div><div>I don't have any support for a "main" method yet, so I wrote a little runner script to test it.</div><div><br /></div><div><script src="https://gist.github.com/3735400.js?file=HelloRunner.java"></script></div><div><br /></div><div>And away we go!</div><div><br /></div><div><script src="https://gist.github.com/3735400.js?file=output.txt"></script></div><div><br /></div><div><div>This is about 30% faster than JRuby with invokedynamic. It is not doing any boundschecking (for rolling over to Bignum) but it is also not caching 1...256 Fixnum objects like JRuby does, nor caching them in any calls along the way (note that it creates three new RFixnums for every recursion that JRuby would not recreate). I call that pretty good.</div><div><br /></div><div>Obviously because this is designed to compile the whole system at once, we could also emit optimized versions of methods that look like they're doing math. That is yet to come, if I continue this little experiment at all.<br /><br />There's also some fun possibilities here. By specifying Java types, the compiler could add normal Java methods. Implementing interfaces could be done directly. And Android applications built with this tool would be entirely statically optimizable, only shipping the small amount of code they actually call and having a very minimal runtime.</div><div><br /></div><div>Pretty neat?</div></div></div>