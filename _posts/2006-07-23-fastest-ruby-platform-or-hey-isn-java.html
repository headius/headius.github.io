---
layout: post
title: The Fastest Ruby Platform? or Hey, Isn't Java Supposed to be Slow?
date: '2006-07-23T00:47:00.000-07:00'
author: headius
tags: 
modified_time: '2011-01-25T21:44:34.407-08:00'
blogger_id: tag:blogger.com,1999:blog-4704664917418794835.post-5172127962691306789
blogger_orig_url: http://blog.headius.com/2006/07/fastest-ruby-platform-or-hey-isn-java.html
---

I love stirring up trouble. In working on the compiler for JRuby, it's become apparent that a few targetted areas could yield tremendous performance benefit even in pure-interpreted mode. I describe a bit of this evening's study here.<br /><br />As an experiment, I cut out a bunch of the stuff in our ThreadContext that caused a lot of overhead for Java-implemented methods. This isn't a safe thing to do for general cases, since most of these items are important, but I wanted to see what bare invocation might do for speed by reducing some of these areas to theoretical "zero cost".<br /><br />Cut from per-method overhead:<br />- block/iter stack manipulation<br />- rubyclass stack manipulation<br /><br />Just two pieces of our overall overhead, but two reasonably expensive pieces not needed for fib().<br /><br />Explanation and wild theories follow the numbers below.<br /><br />Recall that the original <a href="http://headius.blogspot.com/2006/07/compilers-conferences-codehausoh-my.html">compiled fib was only twice as fast</a> as the interpreted version. The new numbers put it closer to 2/3 faster:<br /><br />Time for bi-recursive, interpreted: 18.37<br />Time for bi-recursive, compiled: 6.6160000000000005<br />Time for bi-recursive, interpreted: 17.837<br />Time for bi-recursive, compiled: 6.878<br />Time for iterative, interpreted: 25.222<br />Time for iterative, compiled: 24.885<br /><br />So with the unnecessary overhead removed (simulating zero-cost for those bits of the method call process) we're down to mid 6-seconds for fib(30). The iterative version is calculating fib(500000), but I'll come back to that.<br /><br />Now consider Ruby's own numbers for both of these same tests:<br /><br />Time for bi-recursive, interpreted: 2.001974<br />Time for iterative, interpreted: 9.015137<br /><br />Hmm, now we're not looking so bad anymore, are we? For the recursive version, we're only about 3.5x slower with the reduced overhead. For iterative, only about 2.5x slower. So there's a few other things to consider:<br /><br />- Our benchmark still creates and pushes/pops a frame per invocation<br />- Our benchmark still has fairly costly overhead for method arguments, both on the caller and callee sides (think multiple arrays allocated and copied on both ends)<br />- Our benchmark is still using reflected invocation<br /><br />Yes, the bits I removed simulate zero cost, which we'll never achieve. However, if we assume we'll get close (or at least minimize overhead for cases like this where those removed bits are obviously not needed), these numbers are not unreasonable. If we further assume we can trim more time off each call by simplifying and speeding up argument/param processing, we're even better. If we eliminate framing or reduce its cost in any way, we're better still. However, the third item above is perhaps the most compelling.<br /><br />You should all have seen my <a href="http://headius.blogspot.com/2006/07/is-reflection-really-as-fast-as-direct.html">microbenchmarks for reflected versus direct invocation</a>. Even in the worst comparison, direct invocation (via INVOKEINTERFACE) took at most 1/8 as much time as reflected. The above fib invocation and all the methods it calls are currently using reflected invocation, just like most stuff in JRuby.<br /><br />So what does performance hypothetically look like for 6.5s times 1/8? How does around 0.8s sound? A full 50-60% faster than C Ruby! What about for iterative...24s / 8 = 3s, a solid 66% boost over C Ruby again. Add in the fact that we're missing a bunch of optimizations, and things are looking pretty damn good. Granted, the actual cost of invoking all those reflected methods is somewhat less than the total, but it's very promising. Even if we assume that the cost of the unoptimized bits is 50% of the total time, leaving 50% cost for reflection, we'd basically be on par with C Ruby.<br /><br />It's also interesting to note that the interpreted and compiled times for the iterative version are almost identical. Interpretation is expensive for many things, but not for a simple while loop. The iterative version's code is below:<br /><pre>def fib_iter_ruby(n)<br />   i = 0<br />   j = 1<br />   cur = 1<br />   while cur &lt;= n<br />     k = i<br />     i = j<br />     j = k + j<br />     cur = cur + 1<br />   end<br />   i<br />end</pre><br />This is a good example of code that's very light on interpretation. While loops in Ruby and JRuby boil down in both cases to little more than while loops in the underlying language, interpretation or not. The expense of this method is almost entirely in two areas: variable assignment and method calls, neither of which are sped up by compilation. The similarity of the compiled and interpreted numbers for this iterative algorithm show one thing extremely clearly: our method call overhead really, really stinks. It is here we should focus all our efforts in the short term.<br /><br />Given these new numbers and the fact that we have many optimizations left to do, I think it's now very reasonable to say <span style="font-weight:bold;">we could beat C Ruby performance by the end of the year</span>.<br /><br />Side Note: The compiler work has gone very well, and now supports several types of variables and while loops. This compiler is mostly educational, since it is heavily dependent on the current ThreadContext semantics and primitives. As we attack the call pipeline, the current compiler will break and be left behind, but it has certainly paved the way, showing us what we need to do to make JRuby the fastest Ruby interpreter available.