---
layout: post
title: Busy Bees
date: '2006-08-02T03:52:00.000-07:00'
author: headius
tags: 
modified_time: '2011-01-25T21:44:34.358-08:00'
blogger_id: tag:blogger.com,1999:blog-4704664917418794835.post-5541016186254983109
blogger_orig_url: http://blog.headius.com/2006/08/busy-bees.html
---

I haven't posted anything substantive in a while, but things are moving rapidly forward. Here's a quick summary of what's been going on with JRuby:<br /><br /><span style="font-weight: bold;">RubySpec</span><br /><br />I have launched an effort to build up a Ruby specification, Wiki-style. At <a href="http://www.headius.com/rubyspec">The RubySpec Wiki</a>, contributors can write short pages/articles on any aspect of Ruby: the language, the libraries, or the implementations. The eventual goal of this is to create a comprehensive library of content describing in detail how every aspect of Ruby is *supposed* to work. This in turn will help alternative implementations like JRuby, Ruby.NET, Cardinal, and others ensure they are functioning correctly.<br /><br />CONTRIBUTORS ARE NEEDED! Please create an account and add whatever you can. Found out about a new feature, quirk, or bug in Ruby? Add it! Feel like porting over some core docs in a more spec-like format (i.e. including edge cases and formal semantics)? Go for it! The Spec will only succeed with user contributions. I may sponsor contests to see who can contribute the most...so keep an eye out!<br /><br /><span style="font-weight: bold;">The New RubyTests</span><br /><br />The <a href="http://rubyforge.org/projects/rubytests/">RubyTests</a> project on RubyForge mainly houses the Rubicon suite, a collection of tests originally created for the first PickAxe book and based on Ruby 1.6. Over the past several years, it's been slowly, slowly updated for 1.8, but the library is showing its age. To complicate matters, other test libraries have sprung up to remedy some of Rubicon's deficiencies: <a href="http://blog.zenspider.com/archives/2006/01/move_over_testu.html">BFTS</a>, from the MetaRuby guys, and now a <a href="http://groups.google.com/group/RubyTests">RubyTests</a> project from the Ruby.NET team out of QUT. In addition, contributors to the RubySpec have called for a place to keep tests that go along with the specification. Something had to be done.<br /><br />This past week, I sent out a proposal to all the RubyTests project members and the MetaRuby guys about finally unifying all our efforts under one grand test suite. The response so far has been excellent...Ryan Davis of MetaRuby told me he agrees with my plan, and others on the RubyTests project also agree this is the way to go. The wheels are in motion!<br /><br />I will act as steward for the new RubyTests project, but only to fostor community collaboration. We'll initially consider pulling all the myriad projects under the RubyTests umbrella, and then start discussing issues like what testing framework to use, how or whether to generate tests, and how to provide traceability back to items in the nascent RubySpec. I encourage anyone interested in seeing Ruby improve and flourish on all platforms to join the project and contribute.<br /><br /><span style="font-weight: bold;">Block Refactoring Work</span><br /><br />It recently became apparent that the current block-management code in JRuby (modeled almost exactly on C Ruby) is rather inefficient; doubly so in JRuby because we don't have C tricks like unions and longjmps. Tom also discovered after some research that much of the block-scoping semantics can be pulled out during the parsing process and stored, saving many searches later on. To these ends, we have both been working on refactoring JRuby internals to improve how blocks function.<br /><br />I have been working to modify the call chain to pass blocks along as part of the frame. This simplifies a great many things, since the correct block to which to yield is now just a field-access away (and eventually, just an argument-access away). Previously, multiple stack pushes and pops were necessary to get the correct frame, causing great undue overhead. Also, I have rewired how Proc instances are invoked, so instead of two pushes and two pops on our internal "block stack", it now just calls the proc directly. Much cleaner. The eventual goal of this is to eliminate the "block stack" and also the "iter stack", which maintains a stack of flags indicating whether a block is available or currently executing.<br /><br />Tom's work will make static much of the information about how blocks are scoped, since their relative orientation in the original source provides almost all the information we need. This will allow us to automatically or more quickly locate the appropriate variable when accessing such from within a block, as well as ensuring our variable scoping is handled correctly with multiple nested blocks. He is also keeping in mind that evals can change the list of variables, so the end result should work fine in those cases as well. The end result is that variable scoping will be much more reliable and performant when blocks are involved.<br /><br /><span style="font-weight: bold;">RubyInline for JRuby</span><br /><br />After doing a bit of exploration on <a href="http://www.rubyinside.com/how-to-create-a-ruby-extension-in-c-in-under-5-minutes-100.html">how Ruby extensions are written</a>, I stumbled across yet another post from Ryan Davis about the <a href="http://blog.zenspider.com/archives/2006/08/writing_c_exten.html">beauty and simplicity</a> of <a href="http:/http://www.zenspider.com/ZSS/Products/RubyInline/">RubyInline</a>. I am not a huge C fan, having had my fill of it during my old <a href="http://www.litestep.net/">LiteStep</a> days (I was lead LiteStep dev during the "great redesign" period), but the attraction of RubyInline is undeniable.<br /><br />Ryan and I had a brief discussion over IM, during which we agreed that adding JRuby/Java support to RubyInline would be a really great idea. Then instead of just specifying C code in your RubyInline blocks, you could easily do the following:<br /><pre>class Example<br />inline(:C) do |builder|<br />  builder.c "int test1() {<br />               int x = 10;<br />               return x;<br />             }"<br />end<br />inline(:java) do |builder|<br />  builder.java "public int test1() {<br />               int x = 10;<br />               return x;<br />             }"<br />end<br />end</pre><br />...and know that whether under JRuby or C Ruby, your inlined code would shine through. Look for this effort to pick up soon; Ryan has agreed to include it in RubyInline once it's ready.<br /><br /><span style="font-weight: bold;">Mongrel for JRuby</span><br /><br />Danny Lagrouw and Ola Bini, perennial JRuby community superstars, have been working on implementing the native bits of <a href="http://mongrel.rubyforge.org/">Mongrel</a> in Java. Danny put together a YACC-based HTTP request parser (since we don't have a Java <a href="http://www.cs.queensu.ca/%7Ethurston/ragel/">Ragel</a> yet) and today Ola implemented a quick ternary search tree in Java. With these two pieces working, we just have to wire up Mongrel and try it out in JRuby. It's very close.<br /><br />What's the value of Mongrel when we have servlet containers to host Rails apps? That question answers itself. Name one Rails developer who's enamored of servlet containers. Yeah, I didn't think so. WEBrick is a poor substitute for a real container, and almost all Rails deployments are going Mongrel now. Not supporting Mongrel would be a showstopper for many, many Rails projects. Therefore, we're making it happen.<br /><br /><span style="font-weight: bold;">JRuby Extras!</span><br /><br />I have requested a new project on RubyForge called "JRuby Extras". This project is intended to be a JRuby community love-fest, hosting all the bits and pieces needed to support Ruby apps running under JRuby. It will hold such juicy tidbits as:<br /><ul><br /><li>The upcoming Mongrel support libraries (at least until they're hopefully included in Mongrel proper)</li><li><a href="http://blog.nicksieger.com/">Nick Sieger</a>'s excellent ActiveRecord JDBC adapter (until included in Rails)</li><li>Any other JRuby-related extensions that don't have good homes elsewhere</li><li>Any Java or JRuby-related updates to other projects (like RubyInline) until included directly into those projects</li></ul>Where the main JRuby project has only Tom and I as gatekeepers, the jruby-extras project will be more community-oriented. If you've got a good idea for how JRuby can be improved (think like Groovy, with its ten-thousand add-ons), toss us an email...and get busy!<br /><br />The project, once approved, will be <a href="http://rubyforge.org/projects/jruby-extras">jruby-extras</a> on RubyForge.<br /><br /><span style="font-weight: bold;">Standarizing JRuby Extensions</span><br /><br />There are a number of extensions to JRuby internally, to replace missing C functionality from C Ruby. There are also a number of extensions being developed externally, to support things like Mongrel. Unfortunately, there is no standard way to write JRuby extensions like there is for C Ruby. The APIs that we expose are subject to change, and the Java world brings along its own conventions and expectations for how plugins ought to work. In order to settle this question, I have kicked off a thread on the JRuby dev mailing list.<br /><br />We're going to figure out the best way to support JRuby extensions, along these rough lines:<br /><ul><li>Requiring an extension will look for an extension library just as it does in Ruby; however, it will be looking for a jar file in the load or class paths containing an appropriately-named entry point.</li><li>require "my/extension" will most likely look for extension.jar in under the my/ load or class path, and then load my.ExtensionLibrary contained therein</li><li>Since we'll want to use direct invocation now in JRuby, we'll want an easy way for extensions to have the same benefits. Rather than having them implement direct-callable interfaces, we'll likely build a code generator that can take a class and a list of method mappings and generate all stubs and callables needed for JRuby. This will also simplify our own code classes and extensions as well.</li><li>There are at least two ways within JRuby to define a new class, its metaclass, and their methods. One is easy but a bit broken; the other is correct but cumbersome. Extension writers will get something in the middle...easy but correct, via various helpers and factories. The same model will also be applied internally. Unification!</li></ul><span style="font-weight: bold;">Making a Move</span><br /><br />On a more personal note, there are events afoot that may give me more time to work on JRuby. I won't go into specifics...just let your imagination run wild.