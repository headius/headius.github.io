---
layout: post
title: Creating a Field-Initializing 'new' Method
date: '2007-06-01T00:59:00.000-07:00'
author: headius
tags: 
modified_time: '2011-01-25T21:44:32.808-08:00'
blogger_id: tag:blogger.com,1999:blog-4704664917418794835.post-2154503568735554613
blogger_orig_url: http://blog.headius.com/2007/06/creating-field-initializing-method.html
---

One thing often touted as a missing feature in Ruby is the lack of a constructor form that initializes fields. A few other languages have this feature, including for example Groovy, another JVM dynamic language. The general idea is that if you want to construct an object and initialize a number of fields, you often want to do it in one shot. Rather than modify the class to have additional initializers for all the fields you want to set, there's another option.<br /><br />Because Ruby is so cool, you can add this feature yourself to all classes at the same time.<br /><pre><br />class Class<br />  def new!(*args, &block)<br />    # make sure we have arguments<br />    if args && args.size > 0<br />      # if it's not a Hash, perform a normal "new"<br />      return new(*args, &block) unless Hash === args[-1]<br /><br />      # grab the last arg in the list<br />      last_arg = args.pop<br /><br />      # make sure all fields actually exist<br />      last_arg.each_key {|key|<br />        unless public_instance_methods.include?("#{key}=") do<br />          raise ArgumentError.new(<br />                           "No attr setter for name: #{key}") <br />        end<br />      }<br /><br />      # create the object and set its fields<br />      new_obj = new(*args, &block)<br />      last_arg.each {|key, value|<br />        new_obj.send "#{key}=", value<br />      }<br />    else<br />      # no args, just do a normal "new" with any block passed<br />      new_obj = new(&block)<br />    end<br />    new_obj<br />  end<br />end<br /></pre><br />So with such a simple piece of code, we now have a new! method on all classes that accepts a final parameter--a hash of field names and values--that can be given using Ruby's named-parameter-like syntax. Given a simple class, like the following:<br /><pre><br />class MyObject<br />  attr_accessor :foo<br />  attr_accessor :bar<br />  <br />  def initialize(msg)<br />    puts msg<br />  end<br />end<br /></pre><br />No additional work is needed to use our new! method:<br /><pre><br />x = MyObject.new!("yippee",<br />                    :foo =&gt; "hello", :bar =&gt; "goodbye") <br /> =&gt; "yippee"<br />p [x.foo, x.bar]<br /> =&gt; ["hello", "goodbye"]<br />y = MyObject.new!("blah", :yuck =&gt; "baz")<br /> =&gt; error: "No attr setter for name: yuck"<br /></pre><br />The reason this works is that all classes are instances of the Class class. So the MyObject class definition above is roughly equivalent to saying:<br /><pre><br />MyObject = Class.new {<br />  # class def logic here<br />}<br /></pre><br />This means that instances of Class, like MyObject, inherit methods defined on Class, like new!. Since all classes in the system are Class objects, all classes instantly gain a new! method.<br /><br />This is a perfect example of why Ruby is such a powerful language, and why it's so easy in Ruby to use the coolest metaprogramming tricks. And it's a primary reason why frameworks like Rails have been able to do such amazing things. With a language that's this powerful and this easy, you can imagine what else is possible.<br /><br />Are we having fun yet?