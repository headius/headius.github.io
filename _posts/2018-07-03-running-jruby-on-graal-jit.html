---
layout: post
title: Running JRuby on the Graal JIT
date: '2018-07-03T14:45:00.001-07:00'
author: headius
tags: 
modified_time: '2018-07-03T14:45:32.187-07:00'
thumbnail: https://3.bp.blogspot.com/-NwkSJ4sYN24/WzvkhwwrEWI/AAAAAAABfFA/jB9mui7_Cn07FSozea_StktVS76kB4wiACLcBGAs/s72-c/Screen%2BShot%2B2018-07-03%2Bat%2B3.58.48%2BPM.png
blogger_id: tag:blogger.com,1999:blog-4704664917418794835.post-8192330828395134364
blogger_orig_url: http://blog.headius.com/2018/07/running-jruby-on-graal-jit.html
---

<div dir="ltr" style="text-align: left;" trbidi="on">Hello, friends! Long time no blog!<br /><br />I'm still here hacking away on JRuby for the benefit of Rubyists everywhere, usually slogging through compatibility fixes and new Ruby features. However with the release of JRuby 9.2, we've caught up to Ruby 2.5 (the current release) and I'm spending a little time on performance.<br /><br />I thought today would be a good opportunity to show you how to start exploring some next-generation JRuby performance by running on top of the Graal JIT.<br /><br /><h2 style="text-align: left;">Graal</h2><div style="text-align: left;">The <a href="https://github.com/oracle/graal">Graal JIT</a> is a project that grew out of a Sun Microsystem Labs project called MaxineVM. Maxine was an attempt to implement a JVM entirely in Java...via various specialized Java dialects, annotations, and compilation strategies. Graal is the latest iteration of the JIT work done for Maxine, and provides an optimizing JVM JIT implemented entirely in Java. Maxine only lives on as a research project, but Graal is rapidly shaping up to become the preferred JIT in OpenJDK.</div><div style="text-align: left;"><br /></div><div style="text-align: left;">The majority of optimizations that Graal does to code are no different from the "classic" OpenJDK JIT, Hotspot's "C2" compiler. You get all the usual dead code, loop unrolling, method inlining, branch profiling, and so on. However Graal goes beyond Hotspot in a few key ways. Most interesting to JRuby (and other dynamic languages) is the fact that Graal finally brings good Escape Analysis to the JVM.</div><div style="text-align: left;"><br /></div><h2 style="text-align: left;">Escape Analysis</h2><div style="text-align: left;">The biggest gains JRuby sees running on Graal are from Escape Analysis (EA). The basic idea behind escape analysis goes like this: if you allocate an object, use it and its contents, and then abandon that object all within the same thread-local piece of code (i.e. not storing that object in a globally-visible location) then there's no reason to allocate the object. Think about this in terms of Java's autoboxing or varargs: if you box arguments or numbers, pass them to a method, and then unbox them again...the intermediate box was not really necessary.</div><div style="text-align: left;"><br /></div><div style="text-align: left;">The basic idea of EA is not complicated to understand, but implementing well can be devilishly hard. For example, the Hotspot JIT has had a form of escape analysis for years, optional in Java 7 and I believe turned on by default during Java 8 maintenance releases. However this EA was very limited...if any wrapper object was used across a branch (even a simple if/else) or if it might under any circumstance leave the compiled code being optimized, it would be forced to allocate every time.</div><div style="text-align: left;"><br /></div><div style="text-align: left;">The Graal EA improves on this with a technique called Partial Escape Analysis (PEA). In PEA, branches and loops do not interfere with the process of eliminating objects because all paths are considered. In addition, if there are boxed values eventually passed out of the compiled code, their allocation can be deferred until needed.</div><div style="text-align: left;"><br /></div><h2 style="text-align: left;">JRuby on Graal</h2><div style="text-align: left;">By now you've likely heard about TruffleRuby, a Graal-based Ruby implementation that uses the Truffle framework for implementing all core language features and classes. Truffle provides many cool features for specializing data structures and making sure code inlines, but many of the optimizations TR users see is due to Graal doing such a great job of eliminating transient objects.</div><div style="text-align: left;"><br /></div><div style="text-align: left;">And because Graal is also open source and available in Java 10 and higher, JRuby can see some of those benefits!</div><div style="text-align: left;"><br /></div><div style="text-align: left;">There's two easy ways for you to test out JRuby on the Graal JIT</div><div style="text-align: left;"><br /></div><h3 style="text-align: left;">Using Java 10 with Graal </h3><div style="text-align: left;">OpenJDK 9 included a new feature to pre-compile Java code to native (with the "jaotc" command), and this compiler made use of Graal. In OpenJDK 10, Graal is now included even on platforms where the ahead-of-time compiler is not supported.</div><div style="text-align: left;"><br /></div><div style="text-align: left;"><a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk10-downloads-4416644.html">Download and install any OpenJDK 10</a> (or higher) release, and pass these flags to the JVM (either with -J flags to JRuby or using the JAVA_OPTS environment variable):</div><div style="text-align: left;"><br /></div><div style="text-align: left;">-XX:+UnlockExperimentalVMOptions</div><div style="text-align: left;">-XX:+EnableJVMCI</div><div style="text-align: left;">-XX:+UseJVMCICompiler</div><div style="text-align: left;"><br /></div><h3 style="text-align: left;">Using GraalVM</h3><div style="text-align: left;">GraalVM is a new build of OpenJDK that includes Graal and Truffle by default. Depending on which one you use (community or enterprise edition) you may also have access to additional proprietary optimizations.</div><div style="text-align: left;"><br /></div><div style="text-align: left;">GraalVM can be downloaded in community form for Linux and enterprise form for Linux and MacOS from <a href="https://www.graalvm.org/">graalvm.org</a>. Install it and set it up as the JVM JRuby will run with (JAVA_HOME and/or PATH, as usual). It will use the Graal JIT by default.</div><div style="text-align: left;"><br /></div><h3 style="text-align: left;">Additional JRuby Flags</h3><div style="text-align: left;">You will also want to include some JRuby flags that help us optimize Ruby code in ways that work better on Graal:</div><ul style="text-align: left;"><li>-Xcompile.invokedynamic enables our use of the InvokeDynamic feature, which lets dynamic calls inline and optimize like static Java calls.</li><li>-Xfixnum.cache=false disables our cache of small Fixnum objects. Using the cache helps on Hotspot, which has no reliable escape analysis, but having those objects floating around sometimes confuses Graal's partial escape analysis. Try your code with the cache on and off and let us know how it affects performance.</li></ul><h2 style="text-align: left;">What to Expect</h2><div style="text-align: left;">We have only been exploring how JRuby can make use of Graal over the past few months, but we're already seeing positive results on some benchmarks. However the optimizations we want to see are heavily dependent on inlining all code, an area where we need some work. I present two results here, one where Graal is working like we expect, and another where we're not yet seeing our best results.</div><div style="text-align: left;"><br /></div><h3 style="text-align: left;">Numeric Algorithms Look Good</h3><div style="text-align: left;">One of the biggest areas JRuby performance suffers is in numeric algorithms. On a typical Hotspot-based JVM, all Fixnum and Float objects are actually object boxes that must be allocated and garbage collected like any other object. As you'd expect, this means that numeric algorithms pay a very high cost. This also means that Graal's partial escape analysis gives us huge gains, because all those boxes get swept away.</div><div class="separator" style="clear: both; text-align: center;"><a href="https://3.bp.blogspot.com/-NwkSJ4sYN24/WzvkhwwrEWI/AAAAAAABfFA/jB9mui7_Cn07FSozea_StktVS76kB4wiACLcBGAs/s1600/Screen%2BShot%2B2018-07-03%2Bat%2B3.58.48%2BPM.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="852" data-original-width="1600" height="211" src="https://3.bp.blogspot.com/-NwkSJ4sYN24/WzvkhwwrEWI/AAAAAAABfFA/jB9mui7_Cn07FSozea_StktVS76kB4wiACLcBGAs/s400/Screen%2BShot%2B2018-07-03%2Bat%2B3.58.48%2BPM.png" width="400" /></a></div><br /><div style="text-align: left;"></div><br /><br /><div style="text-align: left;">This first result is from a pure-Ruby Mandelbrot fractal-generating algorithm that makes the rounds periodically. The math here is almost all floating-point, with a few integers thrown in, but the entire algorithm fits in a single method. With JRuby using invokedynamic and running on Graal, all the code inlines and optimizes like a native numeric algorithm! Hooray for partial escape analysis!</div><div style="text-align: left;"><br /></div><div style="text-align: left;">We also have anecdotal reports of other numeric benchmarks performing significantly better with JRuby on Graal than JRuby on Hotspot...and in some cases, JRuby on Graal is the fastest result available!</div><div style="text-align: left;"><br /></div><h3 style="text-align: left;">Data Structures Need More Work</h3><div style="text-align: left;">Of course most applications don't just work with numbers. They usually have a graph of objects in memory they need to traverse, search, create and destroy. In many cases, those objects include Array and Hash instances rather than user-defined objects, and frequently these structures are homogeneous: they contain only numbers, for example.</div><div style="text-align: left;"><br /></div><div style="text-align: left;">JRuby currently does not do everything it could to inline object creation and access. We also are not doing any numeric specialization of structures like Array, which means a list of Fixnums actually has to allocate all those Fixnum objects and hold them in memory. These are areas we intend to work on; I am currently looking at doing some minimal specialization of algorithmic code and numeric data structures, and we will release some specialization code for instance variables (right-sizing the object rather than using a separate array to hold instance variables) in JRuby 9.2.1.</div><div class="separator" style="clear: both; text-align: center;"><a href="https://4.bp.blogspot.com/-FQswQpqF_64/WzvqWhCRc_I/AAAAAAABfFM/ebRE01fIBVssNW3SDXpGR09ecfGRLyM9gCLcBGAs/s1600/Screen%2BShot%2B2018-07-03%2Bat%2B4.27.39%2BPM.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="853" data-original-width="1600" height="212" src="https://4.bp.blogspot.com/-FQswQpqF_64/WzvqWhCRc_I/AAAAAAABfFM/ebRE01fIBVssNW3SDXpGR09ecfGRLyM9gCLcBGAs/s400/Screen%2BShot%2B2018-07-03%2Bat%2B4.27.39%2BPM.png" width="400" /></a></div><br /><div style="text-align: left;">The red/black benchmark tests the performance of a pure-Ruby red/black tree implementation. It creates a large graph, traverses it, searches it, and clears it. JRuby with InvokeDynamic on Hotspot still provides the best result here, perhaps because the extra magic of Graal is not utilized well.</div><br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-FyekceTtJZQ/Wzvq03CN24I/AAAAAAABfFU/Y9uZ_PE8VWw4_sn0vWyyfosl2So5If4rgCLcBGAs/s1600/Screen%2BShot%2B2018-07-03%2Bat%2B4.29.35%2BPM.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="840" data-original-width="1600" height="208" src="https://1.bp.blogspot.com/-FyekceTtJZQ/Wzvq03CN24I/AAAAAAABfFU/Y9uZ_PE8VWw4_sn0vWyyfosl2So5If4rgCLcBGAs/s400/Screen%2BShot%2B2018-07-03%2Bat%2B4.29.35%2BPM.png" width="400" /></a></div><div style="text-align: left;">This benchmark of ActiveRecord shows the opposite result: JRuby on Graal gets the best performance. Without having dug into the details, I'd guess there's some hot loop code in the middle of the "find all" logic, and that loop is optimizing well on Graal. But ultimately the objects all need to be created and the gain from Graal is fairly limited. I also have examples of other read, write, and update operations and only about half of them are faster with Graal.</div><br /><br /><h2 style="text-align: left;">Your Turn</h2><div style="text-align: left;">The JRuby team (of which only two of us are actually employed to work on JRuby) has always managed resources with an eye for compatibility first. This has meant that JRuby performance -- while usually solid and usually faster than CRuby -- has received much less attention than some other Ruby implementations. But it turns out we can get really solid performance simply by inlining all appropriate code, specializing appropriate data structures, and running atop a JIT with good escape analysis.</div><div style="text-align: left;"><br /></div><div style="text-align: left;">We will be working over the next few months to better leverage Graal. In the mean time, we'd love to hear from JRuby users about their experiences with JRuby on Graal! If your code runs faster, let us know so we can tell others. If your code runs slower, let us know so we can try to improve it. And if you're interested in comparing with other Ruby implementations, just make sure your benchmark reflects a real-world case and doesn't simply optimize down to nothing.</div><div style="text-align: left;"><br /></div><div style="text-align: left;">JRuby on Graal has great promise for the future. Try it out and let us know how it goes!</div><br /></div>