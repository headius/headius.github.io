---
layout: post
title: Browsing Memory with Ruby and Java Debug Interface
date: '2010-07-17T14:58:00.000-07:00'
author: headius
tags: 
modified_time: '2011-01-25T21:44:30.373-08:00'
blogger_id: tag:blogger.com,1999:blog-4704664917418794835.post-6351925351093074122
blogger_orig_url: http://blog.headius.com/2010/07/browsing-memory-with-ruby-and-java.html
---

This is the third post in a series. The first two were on <a href="{{ site.baseurl }}{% post_url 2010-07-08-browsing-memory-jruby-way %}">Browsing Memory the JRuby Way</a> and <a href="{{ site.baseurl }}{% post_url 2010-07-12-finding-leaks-in-ruby-apps-with-eclipse %}">Finding Leaks in Ruby Apps with Eclipse Memory Analyzer</a><br /><br />Hello again, friends! I'm back with more exciting memory analysis tips and tricks! Ready? Here we go!<br /><br />After my previous two posts, several folks asked if it's possible to do all this stuff from Ruby, rather than using Java or C-based apps shipped with the JVM. The answer is yes! Because of the maturity of the Java platform, there are standard Java APIs you can use to access all the same information the previous tools consumed. And since we're talking about JRuby, that means you have Ruby APIs you can use to access that information.<br /><br />That's what I'm going to show you today.<br /><br /><span style="font-weight:bold;">Introducing JDI</span><br /><br />The APIs we'll be using are part of the <a href="http://download.oracle.com/docs/cd/E17409_01/javase/6/docs/jdk/api/jpda/jdi/index.html">Java Debug Interface (JDI)</a>, a set of Java APIs for remotely inspecting a running application. It's part of the <a href="http://download.oracle.com/docs/cd/E17409_01/javase/6/docs/technotes/guides/jpda/">Java Platform Debugger Architecture</a>, which also includes a <a href="http://download.oracle.com/docs/cd/E17409_01/javase/6/docs/technotes/guides/jvmti/index.html">C/++ API</a>, a <a href="http://download.oracle.com/docs/cd/E17409_01/javase/6/docs/technotes/guides/jpda/jdwp-spec.html">wire protocol</a>, and a raw <a href="http://download.oracle.com/docs/cd/E17409_01/javase/6/docs/technotes/guides/jpda/jdwpTransport.html">wire protocol API</a>. Exploring those is left as an exercise for the reader...but they're also pretty cool.<br /><br />We'll use the Rails app from before, inspecting it immediately after boot. JDI provides a number of ways to connect up to a running VM, using <a href="http://download.oracle.com/docs/cd/E17409_01/javase/6/docs/jdk/api/jpda/jdi/com/sun/jdi/VirtualMachineManager.html">VirtualMachineManager</a>; you can either have the debugger make the connection or the target VM make the connection, and optionally have the target VM launch the debugger or the debugger launch the target VM. For our example, we'll have the debugger attach to a target VM listening for connections.<br /><br /><span style="font-weight:bold;">Preparing the Target VM</span><br /><br />The first step is to start up the application with the appropriate debugger endpoint installed. This new flag is a bit of a mouthful (and we should make a standard flag for JRuby users), but we're simply setting up a socket-based listener on port 12345, running as a server, and we don't want to suspend the JVM when the debugger connects.<br /><pre>jruby -J-agentlib:jdwp=transport=dt_socket,server=y,address=12345,suspend=n -J-Djruby.reify.classes=true script/server -e production</pre><br />The -J-Djruby.reify.classes bit I talked about in my first post. It makes Ruby classes show up as Java classes for purposes of heap inspection.<br /><br />The rest is just running the server in production mode.<br /><br />As you can see, remote debugging is already baked into the JVM, which means we didn't have to write it or debug it. And that's pretty awesome.<br /><br />Let's connect to our Rails process and see what we can do.<br /><br /><span style="font-weight:bold;">Connecting to the target VM</span><br /><br />In order to connect to the target VM, you need to do the Java factory dance. We start with the <a href="http://download.oracle.com/docs/cd/E17409_01/javase/6/docs/jdk/api/jpda/jdi/com/sun/jdi/Bootstrap.html">com.sun.jdi.Bootstrap class</a>, get a <a href="http://download.oracle.com/docs/cd/E17409_01/javase/6/docs/jdk/api/jpda/jdi/com/sun/jdi/VirtualMachineManager.html">com.sun.jdi.VirtualMachineManager</a>, and then connect to a target VM to get a <a href="http://download.oracle.com/docs/cd/E17409_01/javase/6/docs/jdk/api/jpda/jdi/com/sun/jdi/VirtualMachine.html">com.sun.jdi.VirtualMachine</a> object.<br /><pre>vmm = Bootstrap.virtual_machine_manager<br />sock_conn = vmm.attaching_connectors[0] # not guaranteed to be Socket<br />args = sock_conn.default_arguments<br />args['hostname].value = "localhost"<br />args['port'].value = "12345"<br />vm = sock_conn.attach(args)</pre><br />Notice that I didn't dig out the socket connector explicitly here, because on my system, the first connector always appears to be the socket connector. Here's the full list for me on OS X:<br /><pre>➔ jruby -rjava -e "puts com.sun.jdi.Bootstrap.virtual_machine_manager.attaching_connectors<br />> "<br />[com.sun.jdi.SocketAttach (defaults: timeout=, hostname=charles-nutters-macbook-pro.local, port=),<br />com.sun.jdi.ProcessAttach (defaults: pid=, timeout=)]</pre><br />The ProcessAttach connector there isn't as magical as it looks; all it does is query the target process to find out what transport it's using (dt_socket in our case) and then calls the right connector (e.g. SocketAttach in the case of dt_socket or SharedMemoryAttach if you use dt_shmem on Windows). In our case, we know it's listening on a socket, so we're using the SocketAttach connector directly.<br /><br />The rest is pretty simple: we get the default arguments from the connector, twiddle them to have the right hostname and port number, and attach to the VM. Now we have a VirtualMachine object we can query and twiddle; we're inside the matrix.<br /><br /><span style="font-weight:bold;">With Great Power...</span><br /><br />So, what can we do with this VirtualMachine object? We can:<br /><ul><li>walk all classes and objects on the heap</li><li>install breakpoints and step-debug any running code</li><li>inspect and modify the current state of any running thread, even manipulating in-flight arguments and variables</li><li>replace already-loaded classes with new definitions (such as to install custom instrumentation)</li></ul>Here's the output from JRuby's ri command when we ask about VirtualMachine:<br /><pre>➔ ri --java com.sun.jdi.VirtualMachine<br />-------------------------------------- Class: com.sun.jdi.VirtualMachine<br />     (no description...)<br />------------------------------------------------------------------------<br /><br /><br />Instance methods:<br />-----------------<br />     allClasses, allThreads, canAddMethod, canBeModified,<br />     canForceEarlyReturn, canGetBytecodes, canGetClassFileVersion,<br />     canGetConstantPool, canGetCurrentContendedMonitor,<br />     canGetInstanceInfo, canGetMethodReturnValues,<br />     canGetMonitorFrameInfo, canGetMonitorInfo, canGetOwnedMonitorInfo,<br />     canGetSourceDebugExtension, canGetSyntheticAttribute, canPopFrames,<br />     canRedefineClasses, canRequestMonitorEvents,<br />     canRequestVMDeathEvent, canUnrestrictedlyRedefineClasses,<br />     canUseInstanceFilters, canUseSourceNameFilters,<br />     canWatchFieldAccess, canWatchFieldModification, classesByName,<br />     description, dispose, eventQueue, eventRequestManager, exit,<br />     getDefaultStratum, instanceCounts, mirrorOf, mirrorOfVoid, name,<br />     process, redefineClasses, resume, setDebugTraceMode,<br />     setDefaultStratum, suspend, toString, topLevelThreadGroups,<br />     version, virtualMachine</pre><br />We can basically make the target VM dance any way we want, even going so far as to write our own debugger entirely in Ruby code. But that's a topic for another day. Right now, we're going to do some memory inspection.<br /><br /><b>Creating a Histogram of the Heap</b><br />The simplest heap inspection we might do is to produce a histogram of all objects on the heap. And as you might expect, this is one of the easiest things to do, because it's the first thing everyone looks for when debugging a memory issue.<br /><pre>classes = VM.all_classes<br />counts = VM.instance_counts(classes)<br />classes.zip(counts)</pre><br />VirtualMachine.all_classes gives you a list (a java.util.List, but we make those behave mostly like a Ruby Array) of every class the JVM has loaded, including Ruby classes, JRuby core and runtime classes, and other Java classes that JRuby and the JVM use. VirtualMachine.instance_counts takes that list of classes and returns another list of instance counts. Zip the two together, and we have an array of classes and instance counts. So easy!<br /><br />Let's take these two pieces and put them together in an easy-to-use class<br /><pre>require 'java'<br /><br />module JRuby<br />  class Debugger<br />    VMM = com.sun.jdi.Bootstrap.virtual_machine_manager<br />    <br />    attr_accessor :vm<br />    <br />    def initialize(options = {})<br />      connectors = VMM.attaching_connectors<br />      if options[:port]<br />        connector = connectors.find {|ac| ac.name =~ /Socket/}<br />      elsif options[:pid]<br />        connector = connectors.find {|ac| ac.name =~ /Process/}<br />      end<br /><br />      args = connector.default_arguments<br />      for k, v in options<br />        args[k.to_s].value = v.to_s<br />      end<br />      <br />      @vm = connector.attach(args)<br />    end<br /><br />    # Generate a histogram of all classes in the system<br />    def histogram<br />      classes = @vm.all_classes<br />      counts = @vm.instance_counts(classes)<br />      classes.zip(counts)<br />    end<br />  end<br />end</pre><br />I've taken the liberty of expanding the connection process to handle pids and other arguments passed in. So to get a histogram from a VM listening on localhost port 12345, we can simply do:<br /><pre>JRuby::Debugger.new(:hostname => 'localhost', :port => 12345).histogram</pre><br />Now of course this list is going to have a lot of JRuby and Java objects that we might not be interested in, so we'll want to filter it to just the Ruby classes. On JRuby master, all the generated Ruby classes start with a package name "ruby". Unfortunately, jitted Ruby methods start with a package of "ruby.jit" right now, so we'll want to filter those out too (unless you're interested in them, of course...JRuby is an open book!)<br /><pre>require 'jruby_debugger'<br /><br /># connect to the VM<br />debugr = JRuby::Debugger.new(:hostname => 'localhost', :port => 12345)<br />histo = debugr.histogram<br /># sort by count<br />histo.sort! {|a,b| b[1] <=> a[1]}<br /># filter to only user-created Ruby classes with >0 instances<br />histo.each do |cls,num|<br />  next if num == 0 || cls.name[0..4] != 'ruby.' || cls.name[5..7] == 'jit'<br />  puts "#{num} instances of #{cls.name[5..-1].gsub('.', '::')}"<br />end</pre><br />If we run this short script against our Rails application, we see similar results to the previous posts (but it's cooler, because we're doing it all from Ruby!)<br /><pre>➔ jruby ruby_histogram.rb | head -10<br />11685 instances of TZInfo::TimezoneTransitionInfo<br />1071 instances of Gem::Version<br />1012 instances of Gem::Requirement<br />592 instances of TZInfo::TimezoneOffsetInfo<br />432 instances of Gem::Dependency<br />289 instances of Gem::Specification<br />142 instances of ActiveSupport::TimeZone<br />118 instances of TZInfo::DataTimezoneInfo<br />118 instances of TZInfo::DataTimezone<br />45 instances of Gem::Platform</pre><br />Just so we're all on the same page, it's important to know what we're actually dealing with here. VirtualMachine.all_classes returns a list of <a href="http://download.oracle.com/docs/cd/E17409_01/javase/6/docs/jdk/api/jpda/jdi/com/sun/jdi/ReferenceType.html">com.sun.jdi.ReferenceType</a> objects. Let's ri that.<br /><pre>➔ ri --java com.sun.jdi.ReferenceType<br />--------------------------------------- Class: com.sun.jdi.ReferenceType<br />     (no description...)<br />------------------------------------------------------------------------<br /><br /><br />Instance methods:<br />-----------------<br />     allFields, allLineLocations, allMethods, availableStrata,<br />     classLoader, classObject, compareTo, constantPool,<br />     constantPoolCount, defaultStratum, equals, failedToInitialize,<br />     fieldByName, fields, genericSignature, getValue, getValues,<br />     hashCode, instances, isAbstract, isFinal, isInitialized,<br />     isPackagePrivate, isPrepared, isPrivate, isProtected, isPublic,<br />     isStatic, isVerified, locationsOfLine, majorVersion, methods,<br />     methodsByName, minorVersion, modifiers, name, nestedTypes,<br />     signature, sourceDebugExtension, sourceName, sourceNames,<br />     sourcePaths, toString, virtualMachine, visibleFields,<br />     visibleMethods</pre><br />You can see there's quite a bit more you can do with a ReferenceType. Let's try something.<br /><br /><span style="font-weight:bold;">Digging Deeper Into TimezoneTransitionInfo</span><br /><br />Let's actually take some time to explore our old friend TimezoneTransitionInfo (hereafter referred to as TTI). Instead of walking all classes in the system, we'll want to just grab TTI directly. For that we use VirtualMachine.classes_by_name, which returns a list of classes on the target VM of that name. There should be only one, since we only have a single JRuby instance in our server, so we'll grab that class and request exactly one instance of it...any old instance.<br /><pre>tti_class = debugr.vm.classes_by_name('ruby.TZInfo.TimezoneTransitionInfo')[0]<br />tti_obj = tti_class.instances(1)[0]<br />puts tti_obj</pre><br />Running this we can see we've got the reference we're looking for.<br /><pre>➔ jruby tti_digger.rb<br />instance of ruby.TZInfo.TimezoneTransitionInfo(id=2)</pre><br />ReferenceType.instances returns a list (no larger than the specified size, or all instances if you specify 0) of <a href="http://download.oracle.com/docs/cd/E17409_01/javase/6/docs/jdk/api/jpda/jdi/com/sun/jdi/ObjectReference.html">com.sun.jdi.ObjectReference</a> objects.<br /><pre>➔ ri --java com.sun.jdi.ObjectReference<br />------------------------------------- Class: com.sun.jdi.ObjectReference<br />     (no description...)<br />------------------------------------------------------------------------<br /><br /><br />Instance methods:<br />-----------------<br />     disableCollection, enableCollection, entryCount, equals, getValue,<br />     getValues, hashCode, invokeMethod, isCollected, owningThread,<br />     referenceType, referringObjects, setValue, toString, type,<br />     uniqueID, virtualMachine, waitingThreads</pre><br />Among the weirder things like disabling garbage collection for this object or listing all threads waiting on this object's monitor (a la 'synchronize' in Java), we can access the object's fields through getValue and setValue.<br /><br />Let's examine the instance variables TTI contains. You may recall from previous posts that all Ruby objects in JRuby store their instance variables in an array, to avoid the large memory and cpu cost of storing them in a map. We can grab a reference to that array and display its contents.<br /><pre>var_table_field = tti_class.field_by_name('varTable')<br />tti_vars = tti_obj.get_value(var_table_field)<br />puts "varTable: #{tti_vars}"<br />puts tti_vars.values.map(&:to_s)</pre><br />And the new output:<br /><pre>➔ jruby tti_digger.rb<br />varTable: instance of java.lang.Object[7] (id=13)<br />instance of ruby.TZInfo.TimezoneOffsetInfo(id=15)<br />instance of ruby.TZInfo.TimezoneOffsetInfo(id=16)<br />instance of org.jruby.RubyFixnum(id=17)<br />instance of org.jruby.RubyFixnum(id=18)<br />instance of org.jruby.RubyNil(id=19)<br />instance of org.jruby.RubyNil(id=19)<br />instance of org.jruby.RubyNil(id=19)</pre><br />Since the varTable field is a simple Object[] in Java, the reference we get to it is of type <a href="http://download.oracle.com/docs/cd/E17409_01/javase/6/docs/jdk/api/jpda/jdi/com/sun/jdi/ArrayReference.html">com.sun.jdi.ArrayReference</a>.<br /><pre>➔ ri --java com.sun.jdi.ArrayReference<br />-------------------------------------- Class: com.sun.jdi.ArrayReference<br />     (no description...)<br />------------------------------------------------------------------------<br /><br /><br />Instance methods:<br />-----------------<br />     disableCollection, enableCollection, entryCount, equals, getValue,<br />     getValues, hashCode, invokeMethod, isCollected, length,<br />     owningThread, referenceType, referringObjects, setValue, setValues,<br />     toString, type, uniqueID, virtualMachine, waitingThreads</pre><br />Of course each of these references can be further explored, but already we can see that this TTI instance has seven instance variables: two TimezoneOffsetInfo objects, two Fixnums, and three nils. But we don't have instance variable names!<br /><br />Instance variable names are only stored on the object's class. There, a table of names to offsets is kept up-to-date as new instance variable names are discovered. We can access this from the TTI class reference and combine it with the variable table to get the output we want to see.<br /><pre># get the metaclass object and class reference<br />metaclass_field = tti_class.field_by_name('metaClass')<br />tti_class_obj = tti_obj.get_value(metaclass_field)<br />tti_class_class = tti_class_obj.reference_type<br /><br /># get the variable names from the metaclass object<br />var_names_field = tti_class_class.field_by_name('variableNames')<br />var_names = tti_class_obj.get_value(var_names_field)<br /><br /># splice the names and values together<br />table = var_names.values.zip(tti_vars.values)<br />puts table</pre><br />This looks a bit complicated, but there's actually a lot of boilerplate here we could put into a utility class. For example, the metaClass and variableNames fields are standard on all (J)Ruby objects and classes, respectively. But considering that we're actually walking a remote VM's *live* heap...this is pretty simple code.<br /><br />Here's what our script outputs now:<br /><pre>➔ jruby tti_digger.rb<br />"@offset"<br />instance of ruby.TZInfo.TimezoneOffsetInfo(id=25)<br />"@previous_offset"<br />instance of ruby.TZInfo.TimezoneOffsetInfo(id=26)<br />"@numerator_or_time"<br />instance of org.jruby.RubyFixnum(id=27)<br />"@denominator"<br />instance of org.jruby.RubyFixnum(id=28)<br />"@at"<br />instance of org.jruby.RubyNil(id=29)<br />"@local_end"<br />instance of org.jruby.RubyNil(id=29)<br />"@local_start"<br />instance of org.jruby.RubyNil(id=29)</pre><br />We could go even deeper, but I think you get the idea.<br /><br /><span style="font-weight:bold;">Your Turn</span><br /><br />Here's a <a href="http://gist.github.com/481102">gist of the three scripts we've created</a>, so you can refer to and build off of them. And of course the javadocs and ri docs will help you as well, plus everything we've done here you can do in a jirb session.<br /><br />There's a lot to the JDI API, but once you've got the VirtualMachine object in hand it's pretty easy to follow. As you'd expect from any debugger API, you need to know a bit about how things work on the inside, but through the magic of JRuby it's actually possible to write most of those fancy memory and debugging tools entirely in Ruby. Perhaps this article has peaked your interest in exploring JRuby internals using JDI and you might start to write debugging tools. Perhaps we can ship a few utilities to make some of the boilerplate go away. In any case, I hope this series of articles shows that JRuby users have an amazing library of tools available to them, and you don't even have to leave your comfort zone if you don't want to.<br /><br />Note: The variableNames field is a recent addition to JRuby master, so if you'd like to play with that you'll probably want to build JRuby yourself or wait for a nightly build that picks it up. But you can certainly do a lot of exploring even without that patch.