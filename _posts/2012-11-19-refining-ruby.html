---
layout: post
title: Refining Ruby
date: '2012-11-19T06:38:00.001-08:00'
author: headius
tags: 
modified_time: '2012-11-19T10:36:04.211-08:00'
blogger_id: tag:blogger.com,1999:blog-4704664917418794835.post-5309576998658669333
blogger_orig_url: http://blog.headius.com/2012/11/refining-ruby.html
---

<div dir="ltr" style="text-align: left;" trbidi="on">What does the following code do?<br /><br /><script src="https://gist.github.com/4110634.js?file=ref_1.rb"></script> If you answered "it upcases two strings and adds them together, returning the result" you might be wrong because of a new Ruby feature called "refinements".<br /><br />Let's start with the problem refinements are supposed to solve: monkey-patching.<br /><br /><h2 style="text-align: left;">Monkey-patching</h2><div>In Ruby, all classes are mutable. Indeed, when you define a new class, you're really just creating an empty class and filling it with methods. The ability to mutate classes at runtime has been used (or abused) by many libraries and frameworks to decorate Ruby's core classes with additional (or replacement) behavior. For example, you might add a "camelize" method to String that knows how to convert under_score_names to camelCaseNames. This is lovingly called "monkey-patching" by the Ruby community.</div><div><br /></div><div>Monkey-patching can be very useful, and many patterns in Ruby are built around the ability to modify classes. It can also cause problems if a library patches code in a way the user does not expect (or want), or if two libraries try to apply conflicting patches. Sometimes, you simply don't want patches to apply globally, and this is where refinements come in.<br /><br /></div><h2 style="text-align: left;">Localizing Monkeypatches</h2><div>Refinements have been discussed as a feature for several years, sometimes under the name "selector namespaces". In essence, refinements are intended to allow monkey-patching only within certain limited scopes, like within a library that wants to use altered or enhanced versions of core Ruby types without affecting code outside the library. This is the case within the ActiveSupport library that forms part of the core of Rails.</div><div><br /></div><div>ActiveSupport provides a number of extensions (patches) to the core Ruby classes like String#pluralize, Range#overlaps?, and Array#second. Some of these extensions are intended for use by Ruby developers, as conveniences that improve the readability or conciseness of code. Others exist mostly to support Rails itself. In both cases, it would be nice if we could prevent those extensions from leaking out of ActiveSupport into code that does not want or need them.<br /><br /></div><h2 style="text-align: left;">Refinements</h2><div>In short, refinements provide a way to make class modifications that are only seen from within certain scopes. In the following example, I add a "camelize" method to the String class that's only seen from code within the Foo class.</div><div><br /></div><script src="https://gist.github.com/4110634.js?file=ref_2.rb"></script> <br /><div><br /></div><div>With the Foo class refined, we can see that the "camelize" method is indeed available within the "camelize_string" method but not outside of the Foo class.</div><div><br /></div><script src="https://gist.github.com/4110634.js?file=ref_3.txt"></script> <br /><div><br /></div><div>On the surface, this seems like exactly what we want. Unfortunately, there's a lot more complexity here than meets the eye.<br /><br /></div><h2 style="text-align: left;">Ruby Method Dispatch</h2><div>In order to do a method call in Ruby, a runtime simply looks at the target object's class hierarchy, searches for the method from bottom to top, and upon finding it performs the call. A smart runtime will cache the method to avoid performing this search every time, but in general the mechanics of looking up a method body are rather simple.</div><div><br /></div><div>In an implementation like JRuby, we might cache the method at what's called the "call site"—the point in Ruby code where a method call is actually performed. In order to know that the method is valid for future calls, we perform two checks at the call site: that the incoming object is of the same type as for previous calls; and that the type's hierarchy has not been mutated since the method was cached.</div><div><br /></div><div>Up to now, method dispatch in Ruby has depended solely on the type of the target object. The calling context has not been important to the method lookup process, other than to confirm that visibility restrictions are enforced (primarily for protected methods, since private methods are rejected for non–self calls). That simplicity has allowed Ruby implementations to optimize method calls and Ruby programmers to understand code by simply determining the target object and methods available on it.</div><div><br /></div><div>Refinements change everything.<br /><br /></div><h2 style="text-align: left;">Refinements Basics</h2><div>Let's revisit the camelize example again.</div><div><br /></div><script src="https://gist.github.com/4110634.js?file=ref_2.rb"></script> <br /><div><br /></div><div>The visible manifestation of refinements comes via the "refine" and "using" methods.</div><div><br /></div><div>The "refine" method takes a class or module (the String class, in this case) and a block. Within the block, methods defined (camelize) are added to what might be called a patch set (a la monkey-patching) that can be applied to specific scopes in the future. The methods are not actually added to the refined class (String) except in a "virtual" sense when a body of code activates the refinement via the "using" method.</div><div><br /></div><div>The "using" method takes a refinement-containing module and applies it to the current scope. Methods within that scope should see the refined version of the class, while methods outside that scope do not.</div><div><br /></div><div>Where things get a little weird is in defining exactly what that scope should be and in implementing refined method lookup in such a way that does not negatively impact the performance of unrefined method lookup. In the current implementation of refinements, a "using" call affects all of the following scopes related to where it is called:</div><div><ul style="text-align: left;"><li>The direct scope, such as the top-level of a script, the body of a class, or the body of a method or block</li><li>Classes down-hierarchy from a refined class or module body</li><li>Bodies of code run via eval forms that change the "self" of the code, such as module_eval</li></ul><div>It's worth emphasizing at this point that refinements can affect code far away from the original "using" call site. It goes without saying that refined method calls must now be aware of both the target type and the calling scope, but what of unrefined calls?<br /><br /></div></div><h2 style="text-align: left;">Dynamic Scoping of Method Lookup</h2><div>Refinements (in their current form) basically cause method lookup to be dynamically scoped. In order to properly do a refined call, we need to know what refinements are active for the context in which the call is occurring and the type of the object we're calling against. The latter is simple, obviously, but determining the former turns out to be rather tricky.<br /><br /></div><h3 style="text-align: left;">Locally-applied refinements</h3><div>In the simple case, where a "using" call appears alongside the methods we want to affect, the immediate calling scope contains everything we need. Calls in that scope (or in child scopes like method bodies) would perform method lookup based on the target class, a method name, and the hierarchy of scopes that surrounds them. The key for method lookup expands from a simple name to a name plus a call context.<br /><br /></div><h3 style="text-align: left;">Hierarchically-applied refinements</h3><div>Refinements applied to a class must also affect subclasses, so even when we don't have a "using" call present we still may need to do refined dispatch. The following example illustrates this with a subclass of Foo (building off the previous example).</div><div><br /></div><script src="https://gist.github.com/4110634.js?file=ref_4.rb"></script> <br /><div><br /></div><div>Here, the camelize method is used within a "map" call, showing that refinements used by the Foo class apply to Bar, its method definitions, and any subscopes like blocks within those methods. It should be apparent now why my first example might not do what you expect. Here's my first example again, this time with the Quux class visible.</div><div><br /></div><script src="https://gist.github.com/4110634.js?file=ref_5.rb"></script> <br /><div><br /></div><div>The Quux class uses refinements from the BadRefinement module, effectively changing String#upcase to actually do String#reverse. By looking at the Baz class alone you can't tell what's supposed to happen, even if you are certain that str1 and str2 are always going to be String. Refinements have effectively localized the changes applied by the BadRefinement module, but they've also made the code more difficult to understand; the programmer (or the reader of the code) must know everything about the calling hierarchy to reason about method calls and expected results.<br /><br /></div><h3 style="text-align: left;">Dynamically-applied refinements</h3><div>One of the key features of refinements is to allow block-based DSLs (domain-specific languages) to decorate various types of objects without affecting code outside the DSL. For example, an RSpec spec.</div><div><br /></div><script src="https://gist.github.com/4110634.js?file=ref_6.rb"></script> <br /><div><br /></div><div>There's several calls here that we'd like to refine.</div><div><ul style="text-align: left;"><li>The "describe" method is called at the top of the script against the "toplevel" object (essentially a singleton Object instance). We'd like to apply a refinement at this level so "describe" does not have to be defined on Object itself.</li><li>The "it" method is called within the block passed to "describe". We'd like whatever self object is live inside that block to have an "it" method without modifying self's type directly.</li><li>The "should" method is called against an instance of MyClass, presumably a user-created class that does not define such a method. We would like to refine MyClass to have the "should" method only within the context of the block we pass to "it".</li><li>Finally, the "be_awesome" method—which RSpec translates into a call to MyClass#awesome?—should be available on the self object active in the "it" block without actually adding be_awesome to self's type.</li></ul><div>In order to do this without having a "using" present in the spec file itself, we need to be able to dynamically apply refinements to code that might otherwise not be refined. The current implementation does this via Module#module_eval (or its argument-receiving brother, Module#module_exec).</div></div><div><br /></div><div>A block of code passed to "module_eval" or "instance_eval" will see its self object changed from that of the original surrounding scope (the self at block creation time) to the target class or module. This is frequently used in Ruby to run a block of code as if it were within the body of the target class, so that method definitions affect the "module_eval" target rather than the code surrounding the block.</div><div><br /></div><div>We can leverage this behavior to apply refinements to any block of code in the system. Because refined calls must look at the hierarchy of classes in the surrounding scope, every call in every block in every piece of code can potentially become refined in the future, if the block is passed via module_eval to a refined hierarchy. The following simple case might not do what you expect, even if the String class has not been modified directly.</div><div><br /></div><script src="https://gist.github.com/4110634.js?file=ref_7.rb"></script> <br /><div><br /></div><div>Because the "+" method is called within a block, all bets are off. The str_ary passed in might not be a simple Array; it could be any user class that implements the "inject" method. If that implementation chooses, it can force the incoming block of code to be refined. Here's a longer version with such an implementation visible.</div><div><br /></div><script src="https://gist.github.com/4110634.js?file=ref_8.rb"></script> <br /><div><br /></div><div>Suddenly, what looks like a simple addition of two strings produces a distinctly different result.</div><div><br /></div><script src="https://gist.github.com/4110634.js?file=ref_9.txt"></script> <br /><div><br /></div><div>Now that you know how refinements work, let's discuss the problems they create.<br /><br /></div><h2 style="text-align: left;">Implementation Challenges</h2><div>Because I know that most users don't care if a new, useful feature makes my life as a Ruby implementer harder, I'm not going to spend a great deal of time here.&nbsp;My concerns revolve around the complexities of knowing when to do a refined call and how to discover those refinements.</div><div><br /></div><div>Current Ruby implementations are all built around method dispatch depending solely on the target object's type, and much of the caching and optimization we do depends on that. With refinements in play, we must also search and guard against types in the caller's context, which makes lookup much more complicated. Ideally we'd be able to limit this complexity to only refined calls, but because "using" can affect code far away from where it is called, we often have no way to know whether a given call might be refined in the future. This is especially pronounced in the "module_eval" case, where code that isn't even in the same class hierarchy as a refinement must still observe it.</div><div><br /></div><div>There are numerous ways to address the implementation challenges.<br /><br /></div><h3 style="text-align: left;">Eliminate the "module_eval" Feature</h3><div>At present, nobody knows of an easy way to implement the "module_eval" aspect of refinements. The current implementation in MRI does it in a brute-force way, flushing the global method cache on every execution and generating a new, refined, anonymous module for every call. Obviously this is not a feasible direction to go; block dispatch will happen very frequently at runtime, and we can't allow refined blocks to destroy performance for code elsewhere in the system.</div><div><br /></div><div>The basic problem here is that in order for "module_eval" to work, every block in the system must be treated as a refined body of code all the time. That means that calls inside blocks throughout the system need to search and guard against the calling context even if no refinements are ever applied to them. The end result is that those calls suffer complexity and performance hits across the board.</div><div><br /></div><div>At the moment, I do not see (nor does anyone else see) an efficient way to handle the "module_eval" case. It should be removed.<br /><br /></div><h3 style="text-align: left;">Localize the "using" Call</h3><div>No new Ruby feature should cause across-the-board performance hits; one solution is for refinements to be recognized at parse time. This makes it easy to keep existing calls the way they are and only impose refinement complexity upon method calls that are actually refined.</div><div><br /></div><div>The simplest way to do this is also the most limiting and the most cumbersome: force "using" to only apply to the immediate scope. This would require every body of code to "using" a refinement if method calls in that body should be refined. Here's a couple of our previous examples with this modification.</div><div><br /></div><script src="https://gist.github.com/4110634.js?file=ref10.rb"></script> <br /><div><br /></div><div>This is obviously pretty ugly, but it makes implementation much simpler. In every scope where we see a "using" call, we simply force all future calls to honor refinements. Calls appearing outside "using" scopes do not get refined and perform calls as normal.</div><div><br /></div><div>We can improve this by making "using" apply to child scopes as well. This still provides the same parse-time "pseudo-keyword" benefit without the repetition.</div><div><br /></div><script src="https://gist.github.com/4110634.js?file=ref11.rb"></script> <br /><div><br /></div><div>Even better would be to officially make "using" a keyword and have it open a refined scope; that results in a clear delineation between refined and unrefined code. I show two forms of this below; the first opens a scope like "class" or "module", and the second uses a "do...end" block form.</div><div><br /></div><script src="https://gist.github.com/4110634.js?file=ref12.rb"></script> <br /><div><br /></div><div>It would be fair to say that requiring more explicit scoping of "using" would address my concern about knowing when to do a refined call. It does not, however, address the issues of locating active refinements at call time.<br /><br /></div><h3 style="text-align: left;">Locating Refinements</h3><div>In each of the above examples, we still must pass some state from the calling context through to the method dispatch logic. Ideally we'd only need to pass in the calling object, which is already passed through for visibility checking. This works for refined class hierarchies, but it does not work for the RSpec case, since the calling object in some cases is just the top-level Object instance (and remember we don't want to decorate Object).</div><div><br /></div><div>It turns out that there's already a feature in Ruby that follows lexical scoping: constant lookup. When Ruby code accesses a constant, the runtime must first search all enclosing scopes for a definition of that constant. Failing that, the runtime will walk the self object's class hierarchy. This is similar to what we want for the simplified version of refinements.</div><div><br /></div><div>If we assume we've localized refinements to only calls within "using" scopes, then at parse time we can emit something like a RefinedCall for every method call in the code. A RefinedCall would be special in that it uses both the containing scope and the target class to look up a target method. The lookup process would proceed as follows:</div><div><ol style="text-align: left;"><li>Search the call's context for refinements, walking lexical scopes only</li><li>If refinements are found, search for the target method</li><li>If a refined method is found, use it for the call</li><li>Otherwise, proceed with normal lookup against the target object's class</li></ol><div>Because the parser has already isolated refinement logic to specific calls, the only change needed is to pass the caller's context through to method dispatch.<br /><br /></div></div><h2 style="text-align: left;">Usability Concerns</h2><div>There are indeed flavors of refinements that can be implemented reasonably efficiently, or at least implemented in such a way that unrefined code will not pay a price. I believe this is a requirement of any new feature: do no harm. But harm can come in a different form if a new feature makes Ruby code harder to reason about. I have some concerns here.</div><div><br /></div><div>Let's go back to our "module_eval" case.</div><div><br /></div><script src="https://gist.github.com/4110634.js?file=ref_7.rb"></script> <br /><div><br /></div><div>Because there's no "using" anywhere in the code, and we're not extending some other class, most folks will assume we're simply concatenating strings here. After all, why would I expect my "+" call to do something else? Why <b>should</b>&nbsp;my "+" call ever do something else here?</div><div><br /></div><div>Ruby has many features that might be considered a little "magical". In most cases, they're only magic because the programmer doesn't have a good understanding of how they work. Constant lookup, for example, is actually rather simple...but if you don't know it searches both lexical and hierarchical contexts, you may be confused where values are coming from.</div><div><br /></div><div>The "module_eval" behavior of refinements simply goes too far. It forces every Ruby programmer to second-guess every block of code they pass into someone else's library or someone else's method call. The guarantees of standard method dispatch no longer apply; you need to know if the method you're calling will change what calls your code makes. You need to understand the internal details of the target method. That's a terrible, terrible thing to do to Rubyists.</div><div><br /></div><div>The same goes for refinements that are active down a class hierarchy. You can no longer extend a class and know that methods you call actually do what you expect. Instead, you have to know whether your parent classes or their ancestors refine some call you intend to make. I would argue this is considerably <b>worse</b>&nbsp;than directly monkey-patching some class, since at least in that case every piece of code has a uniform view.</div><div><br /></div><div>The problems are compounded over time, too. As libraries you use change, you need to again review them to see if refinements are in play. You need to understand all those refinements just to be able to reason about your own code. And you need to hope and pray two libraries you're using don't define different refinements, causing one half of your application to behave one way and the other half of your application to behave another way.</div><div><br /></div><div>I believe the current implementation of refinements introduces more complexity than it solves, mostly due to the lack of a strict lexical "using". Rubyists should be able to look at a piece of code and know what it does based solely on the types of objects it calls. Refinements make that impossible.<br /><br /><i style="font-weight: bold;">Update:</i>&nbsp;Josh Ballanco points out another usability problem: "using" only affects method bodies defined temporally after it is called. For example, the following code only refines the "bar" method, not the "foo" method.<br /><br /><script src="https://gist.github.com/4110634.js?file=ref13.rb"></script><br />This may simply be an artifact of the current implementation, or it may be specified behavior; it's hard to tell since there's no specification of any kind other than the implementation and a handful of tests. In any case, it's yet another confusing aspect, since it means the order in which code is loaded can actually change which refinements are active.<br /><br /></div><h2 style="text-align: left;">tl;dr</h2><div>My point here is not to beat down refinements. I agree there are cases where they'd be very useful, especially given the sort of monkey-patching I've seen in the wild. But the current implementation overreaches; it provides several features of questionable value, while simultaneously making both performance and understandability harder to achieve. Hopefully we'll be able to work with Matz and ruby-core to come up with a more reasonable, limited version of refinements...or else convince them not to include refinements in Ruby 2.0.</div></div>