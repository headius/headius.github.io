---
layout: post
title: The Power of Java's NIO
date: '2008-03-30T07:37:00.000-07:00'
author: headius
tags: 
modified_time: '2011-01-25T21:44:31.789-08:00'
blogger_id: tag:blogger.com,1999:blog-4704664917418794835.post-424209800416068610
blogger_orig_url: http://blog.headius.com/2008/03/power-of-java-nio.html
---

Akira Tanaka just did a lightning talk on IO.copy_stream, a new method added to Ruby 1.9 last night that does a fast stream transfer all in C code, avoiding the intermediate strings. It's a good idea, one I hope takes hold for other IO operations that could use some native lovin.<br /><br />It's so good, in fact, I took five minutes out of my day to produce a crude implementation of it in JRuby (and note, I have not looked at Akira's implementation, so I'm sure it handles cases my version does not):<br /><pre>@JRubyMethod(name = "copy_stream", meta = true, compat = RUBY1_9)<br />public static IRubyObject copy_stream(<br />        IRubyObject recv, IRubyObject stream1, IRubyObject stream2)<br />        throws IOException {<br />    RubyIO io1 = (RubyIO)stream1;<br />    RubyIO io2 = (RubyIO)stream2;<br /><br />    ChannelDescriptor d1 = io1.openFile.getMainStream().getDescriptor();<br />    if (!d1.isSeekable()) {<br />        throw recv.getRuntime().newTypeError("only supports file-to-file copy");<br />    }<br />    ChannelDescriptor d2 = io2.openFile.getMainStream().getDescriptor();<br />    if (!d2.isSeekable()) {<br />        throw recv.getRuntime().newTypeError("only supports file-to-file copy");<br />    }<br /><br />    FileChannel f1 = (FileChannel)d1.getChannel();<br />    FileChannel f2 = (FileChannel)d2.getChannel();<br /><br />    long size = f1.size();<br /><br />    f1.transferTo(f2.position(), size, f2);<br /><br />    return recv.getRuntime().newFixnum(size);<br />}</pre>It's primitive, but it does the trick. NIO streams unfortunately only provide this nice "transferTo" method for FileChannel, though there's other ways you can do fast copies from stream to stream using buffers. But this was a nice simple way to wire it up for now. So, let's see numbers.<br /><pre>require 'benchmark'<br /><br />Benchmark.bmbm do |bm|<br />  bm.report("Control") do<br />    10000.times do<br />      File.open(__FILE__) do |file|<br />        File.open(__FILE__ + ".tmp", 'w') do |file2|<br />        end<br />      end<br />    end<br />  end<br />  bm.report("10k file copies") do<br />    10000.times do<br />      File.open(__FILE__) do |file|<br />        File.open(__FILE__ + ".tmp", 'w') do |file2|<br />          IO.copy_stream(file, file2)<br />        end<br />      end<br />    end<br />  end<br />end</pre>First JRuby numbers (excluding rehearsal):<br /><pre>                      user     system      total        real<br />Control           2.191000   0.000000   2.191000 (  2.191000)<br />10k file copies   5.190000   0.000000   5.190000 (  5.190000)</pre>Not bad for 10k copies of a file...it works out to about 3s above and beyond the cost of running the blocks and opening/closing the files. How about Ruby 1.9?<br /><pre>                      user     system      total        real<br />Control           0.360000   0.550000   0.910000 (  0.903211)<br />10k file copies   0.850000   2.450000   3.300000 (  5.363433)</pre>Ruby 1.9's numbers come out around 4.4s above and beyond the control logic. Obviously we need to look at improving JRuby's numbers for the blocks and file opening, but it's good to know that Java's IO actually *can* be nice and fast when you need it to be.<br /><br />This feature will only be available as part of JRuby's 1.9 support, which is still in development.