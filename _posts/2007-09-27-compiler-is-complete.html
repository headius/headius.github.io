---
layout: post
title: The Compiler Is Complete
date: '2007-09-27T19:33:00.000-07:00'
author: headius
tags: 
modified_time: '2011-01-25T21:44:32.485-08:00'
blogger_id: tag:blogger.com,1999:blog-4704664917418794835.post-1667957868421818728
blogger_orig_url: http://blog.headius.com/2007/09/compiler-is-complete.html
---

It is a glorious day in JRuby-land, for the compiler is now complete.<br /><br />Tom and I have been traveling in Europe the past two weeks, first for RailsConf EU in Berlin and currently in Ã…rhus, Denmark for JAOO (which was an excellent conference, I highly recommend it). And usually, that would mean getting very little work done...but time is short, and I've been putting in full days for almost the entire trip.<br /><br />Let's recap my compiler-related commits made on the road:<br /><ul><li><span style="font-weight: bold;">r4330, Sep 16:</span> ClassVarDeclNode and RescueNode compiling; all tests pass...we're in the home stretch now!</li><li><span style="font-weight: bold;">r4339, Sep 17:</span> Fix for return in rescue not bubbling all the way out of the synthetic method generated to wrap it.</li><li><span style="font-weight: bold;">r4341, Sep 17:</span> Adding super compilation, disabled until the whole findImplementers thing is tidied up in the generated code.</li><li><span style="font-weight: bold;">r4342, Sep 17:</span> Enable super compilation! I had to disable an assertion to do it, but it doesn't seem to hurt things and I have a big fixme on it.</li><li><span style="font-weight: bold;">r4355, Sep 19:</span> zsuper is getting closer, but still not enabled.</li><li><span style="font-weight: bold;">r4362, Sep 20:</span> Enabled a number of additional flow-control syntax within ensure bodies, and def within blocks.</li><li><span style="font-weight: bold;">r4363, Sep 20:</span> Re-disabling break in ensure; it caused problems for Rails and needs to be investigated in more depth.</li><li><span style="font-weight: bold;">r4367, Sep 21:</span> Removing the overhead of constructing ISourcePosition objects for every line in the compiler; I moved construction to be a one-time <clinit> cost and perf numbers went back to where they were before.</clinit></li><li><clinit><span style="font-weight: bold;">r4368, Sep 21:</span> Small optz for literal string perf and memory use: cache a single bytelist per literal in the compiled class and share it across all literal strings constructed.</clinit></li><li><clinit><span style="font-weight: bold;">r4370, Sep 22:</span> Enable compilation of multiple assignment with args (rest args)</clinit></li><li><clinit><span style="font-weight: bold;">r4375, Sep 24:</span> Total refactoring of zsuper argument processing, and zsuper is now enabled in the compiler. We still need more/better tests and specs for zsuper, unfortunately.</clinit></li><li><clinit><span style="font-weight: bold;">r4377, Sep 24:</span> Compile the remaining part of case/when, for when *whatever (appears as nested when nodes in the ast...why?)</clinit></li><li><clinit><span style="font-weight: bold;">r4388, Sep 25:</span> Add compilation of global and constant assignment in masgn/block args</clinit></li><li><clinit><span style="font-weight: bold;">r4392, Sep 25:</span> Compilation of break within ensurified sections; basically just do a normal breakjump instead of Java jumps</clinit></li><li><clinit><span style="font-weight: bold;">r4400, Sep 25:</span> Fix for JRUBY-1388, plus an additional fix where it wasn't scoping constants in the right module.</clinit></li><li><clinit><span style="font-weight: bold;">r4401, Sep 25:</span> Retry compilation!</clinit></li><li><clinit><span style="font-weight: bold;">r4402, Sep 26:</span> Multiple additional cleanups, fixes, to the compiler; expand stack-based methods to include those with opt/rest/block args, fix a problem with redo/next in ensure/rescue; fix an issue in the ASTInspector not inspecting opt arg values; shrink the generated bytecode by offloading to CompilerHelpers in a few places. Ruby stdlib now compiles completely. Yay!</clinit></li><li><clinit><span style="font-weight: bold;">r4404, Sep 26:</span> Add ASM "CheckClass" adapter to command-line (class file dumping) part of compiler.</clinit></li><li><clinit><span style="font-weight: bold;">r4405, Sep 26:</span> A few additional fixes for rescue method names and reduced size for the pre-allocated calladapters, strings, and positions.</clinit></li><li><clinit><span style="font-weight: bold;">r4410, Sep 27:</span> A number of additional fixes for the compiler to remedy inconsistent stack issues, and a whole slew of work to make apps run correctly with AOT-compiled stdlib. Very close to "complete" in my eyes.</clinit></li><li><clinit><span style="font-weight: bold;">r4412, Sep 27:</span> Fixes to top-level scoping for AOT-compiled methods, loading sequence, and some minor compiler tweaks to make rubygems start up and run correctly with AOT-compiled stdlib.</clinit></li><li><clinit><span style="font-weight: bold;">r4413, Sep 27:</span> Fixed the last known bug in the compiler. It is now complete.</clinit></li><li><clinit><span style="font-weight: bold;">r4414, Sep 27:</span> Ok, now the compiler is REALLY complete. I forgot about BEGIN and END nodes. The only remaining node that doesn't compile is OptN, whichwe won't put in the compiled output (we'll just wrap execution of scripts with the appropriate logic). It's a good day to be alive!</clinit></li></ul>I think I've done a decent job proving you can get some serious work done on the road, even while preparing two talks and hob-nobbing with fellow geeks. But of course this is an enormous milestone for JRuby in general.<br /><br />For the first time ever, there is a complete, fully-functional Ruby 1.8 compiler. There have been other compilers announced that were able to handle all Ruby syntax, and perhaps even compile the entire standard library. But they have never gotten to what in my eyes is really "complete": being able to dump the stdlib .rb files and continue running nontrivial applications like IRB or RubyGems. I think I'm allowed to be a little proud of that accomplishment. JRuby has the first complete and functional 1.8-semantics compiler. That's pretty cool.<br /><br />What's even more cool is that this has all been accomplished while keeping a fully-functional interpreter working in concert. We've even made great strides in speeding up interpreted mode to almost as fast as the C implementation of Ruby 1.8, and we still have more ideas. So for the first time, there's a mixed-mode Ruby runtime that can run interpreted, compiled, or both at the same time. Doubly cool. This also means that we don't have to pay a massive compilation cost for 'eval' and friends, and that we can be deployed in a security-restricted environment where runtime code-generation is forbidden.<br /><br />I will try to prepare a document soon about the design of the compiler, the decisions made, and what the future holds. But for now, I have at least one teaser for you to chew on: there is a second compiler in the works, this time for creating real Java classes you can construct and invoke directly from Java-land. Yes, you heard me.<br /><br /><span style="font-weight: bold;">Compiler #2</span><br /><br />Compiler #2 will basically take a Ruby class in a given file (or multiple Ruby classes, if you so choose) and generate a normal Java type. This type will look and feel like any other Java class:<br /><ul><li>You can instantiate it with a normal new MyClass(arg1, arg2) from Java code</li><li>You can invoke all its methods with normal Java invocations</li><li>You can extend it with your own Java classes</li></ul>The basic idea behind this compiler is to take all the visible signatures in a Ruby class definition, as seen during a quick walk through the code, and turn them into Java signatures on a normal class. Behind the scenes, those signatures will just dynamically invoke the named method, passing arguments through as normal. So for example, a piece of Ruby code like this:<br /><pre>class MyClass<br /> def initialize(arg1, arg2); end<br /> def method1(arg1); end<br /> def method2(arg1, arg2 = 'foo', *arg3); end<br />end</pre>Might produce a Java class equivalent to this:<br /><pre>public class MyClass extends RubyObject {<br />   public MyClass(Object arg1, Object arg2) {<br />       callMethod("initialize", arg1, arg2);<br />   }<br /><br />   public Object method1(Object arg1) {<br />       return callMethod("method1", arg1);<br />   }<br /><br />   public Object method2(Object arg1, Object... optAndRest) {<br />       return callMethod("method2", arg1, optAndRest);<br />   }<br />}</pre>It's a pretty trivial amount of code to generate, but it completes that "last mile" of Java integration, being directly callable from Java and directly integrated into Java type hierarchies. Triply cool?<br /><br />Of course the use of Object everywhere is somewhat less than ideal, so I've been thinking through implementation-independent ways to specify signatures for Ruby methods. The requirement in my mind is that the same code can run in JRuby and any other Ruby without modification, but in JRuby it will gain additional static type signatures for calls from Java. The syntax I'm kicking around right now looks something like this:<br /><pre>class MyClass<br />...<br /> {String => [Integer, Array]}<br /> def mymethod(num, ary); end<br />end</pre>If you're unfamiliar with it, this is basically just a literal hash syntax. The return type, String, is associated with the types of the two method arguments, Integer and Array. In any normal Ruby implementation, this line would be executed, a hash constructed, and execution would proceed with the hash likely getting quickly garbage collected. However Compiler #2 would encounter these lines in the class body and use them to create method signatures like this:<br /><pre>    public String mymethod(int num, List ary) {<br />       ...<br />   }</pre><br />The final syntax is of course open for debate, but I can assure you this compiler will be far easier to write than the general compiler. It may not be complete before JRuby 1.1 in November, but it won't take long.<br /><br />So there you have it, friends. Our work on JRuby has shown that it is possible to fully compile Ruby code for a general-purpose VM, and even that Ruby can be made to integrate as a first-class citizen on the Java platform, fitting in wherever Java code may be used today.<br /><br />Are you as excited as I am?