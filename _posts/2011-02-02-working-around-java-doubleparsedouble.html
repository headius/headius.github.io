---
layout: post
title: Working Around the Java Double.parseDouble Bug
date: '2011-02-02T10:14:00.000-08:00'
author: headius
tags: 
modified_time: '2011-02-02T15:12:27.669-08:00'
blogger_id: tag:blogger.com,1999:blog-4704664917418794835.post-6627578193167913100
blogger_orig_url: http://blog.headius.com/2011/02/working-around-java-doubleparsedouble.html
---

You may have seen recently that Java suffers from a similar <a href="http://www.exploringbinary.com/java-hangs-when-converting-2-2250738585072012e-308/">floating-point parsing bug</a> to the one that recently affected PHP users. The basic gist of it is that for this special 64-bit floating point value, the Java call Double.parseDouble("2.2250738585072012e-308") will get stuck in an infinite loop. Read the link above to understand what's happening.<br /><br />Naturally, this affects all JVM languages too, since we all use Double.parseDouble for something or another. In fact, it affects almost all the JVM language parsers and compilers (including javac itself), since they need to turn strings into doubles.<br /><br />Being the upright citizens we are on the JRuby team, we figured we'd try to beat Oracle to the punch and patch around the bug, at least for Ruby-land conversions of String to Float.<br /><br />I started by looking for calls to Double.parseDouble in JRuby. It turned out there were only two: one for the lexer, and one used by String#to_f, BigDecimal#new, and so on. That was a relief; I expected to find dozens of calls.<br /><br />It also turned out all cases had already parsed out Ruby float literal oddities, like underscores, using 'd' or 'D' for the exponentiation marker, allowing ill-formatted exponents to be treated as zero, and so on.<br /><br />My first attempt was to simply normalize the cleaned-up string and pass it to new java.math.BigDecimal(), converting that result back to a primitive double. Unfortunately, BigDecimal's constructor *also* passes through the offending Double.parseDouble code, and we're back where we started.<br /><br />Ultimately, I ended up with the following code. I make no claims this is efficient, but it appears to pass all the Float tests and specs for JRuby and does not DOS like the bad code in Double.parseDouble:<br /><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">&nbsp;&nbsp; &nbsp;public static double parseDouble(String value) {</span><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;String normalString = normalizeDoubleString(value);</span><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;int offset = normalString.indexOf('E');</span><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;BigDecimal base;</span><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;int exponent;</span><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;if (offset == -1) {</span><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;base = new BigDecimal(value);</span><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;exponent = 0;</span><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;} else {</span><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;base = new BigDecimal(normalString.substring(0, offset));</span><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;exponent = Integer.parseInt(normalString.charAt(offset + 1) == '+' ?</span><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;normalString.substring(offset + 2) :</span><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;normalString.substring(offset + 1));</span><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;}</span><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;return base.scaleByPowerOfTen(exponent).doubleValue();</span><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">&nbsp;&nbsp; &nbsp;}</span><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;"><br /></span><br /><span class="Apple-style-span" style="font-family: inherit;">I didn't say it was particularly clever or efficient...but there you have it. A few notes:</span><br /><ul><li>Do I really need UNLIMITED precision here? I almost used it to ensure there's no peculiarities passing through BigDecimal on the way to double, but are any such peculiarities outside 128-bit precision?</li><li>It might have been more efficient to normalize the decimal position and exponent and then see if it matched the magic value. But of course this magic value was not known until recently, so why risk there being another one?</li><li>Using BigDecimal is also lazy. I am lazy.</li></ul><div>I welcome improvements. Everyone will probably need to start using code like this, since there will be a lot of unpatched JVMs out there for a long time.<br /><br />I'm happy to say JRuby will be the first JVM language to route around the Double.parseDouble bug :)<br /><br /><i style="font-weight: bold;">Update: </i>The JRuby commit with this logic is&nbsp;<a href="https://github.com/jruby/jruby/commit/4c712963885c0117b95066d927520a6a738c2a65">4c71296</a>, and the JRuby bug is at&nbsp;<a href="http://jira.codehaus.org/browse/JRUBY-5441">http://jira.codehaus.org/browse/JRUBY-5441</a>.<br /><br /><i style="font-weight: bold;">Update:</i>&nbsp;A commented on Hacker News pointed out that BigDecimal.doubleValue actually just converts to a string and calls Double.parseDouble. So unfortunately, the mechanism above only worked in an earlier version where I was losing some precision by calling Math.pow(10, exponent) rather than scaleByPowerOfTen. The version above unfortunately does <b>not work</b>, so it's back to the drawing board. C'est la vie!</div>