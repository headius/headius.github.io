---
layout: post
title: Closures Prototype Applied to JRuby Compiler
date: '2007-11-05T00:26:00.000-08:00'
author: headius
tags: 
modified_time: '2011-01-25T21:44:32.351-08:00'
blogger_id: tag:blogger.com,1999:blog-4704664917418794835.post-2073107812380954630
blogger_orig_url: http://blog.headius.com/2007/11/closures-prototype-applied-to-jruby.html
---

A bit ago, I was catching up on my feeds and noticed that Neal Gafter had announced the first prototype of <a href="http://gafter.blogspot.com/2007/10/java-closures-first-prototype.html">Java closures</a>. I've been a fan of the BGGR proposal, so I thought I'd catch up on the current status and try applying it to a pain point in the JRuby source: the compiler.<br /><br />The current compiler is made up of two halves: the AST walker and the bytecode emitter. The AST walker recursively walks the AST, calling appropriate methods on a set of interfaces into the bytecode emitter. The bytecode emitter, in turn, spits out appropriate bytecodes and calls back to the AST walker. Back and forth, the AST is traversed and all nested structures are assembled appropriately into a functional Java method.<br /><br />This back and forth is key to the structure and relative simplicity of the compiler. Take for example the following method in ASTCompiler.java, which compiles a Ruby "next" keyword (similar to Java's "continue"):<br /><span style=";font-family:courier new;font-size:85%;"  ><pre>public static void compileNext(Node node, MethodCompiler context) {<br />  context.lineNumber(node.getPosition());<br /><br />  final NextNode nextNode = (NextNode) node;<br /><br />  ClosureCallback valueCallback = new ClosureCallback() {<br />      public void compile(MethodCompiler context) {<br />          if (nextNode.getValueNode() != null) {<br />              ASTCompiler.compile(nextNode.getValueNode(), context);<br />          } else {<br />              context.loadNil();<br />          }<br />      }<br />  };<br /><br />  context.pollThreadEvents();<br />  context.issueNextEvent(valueCallback);<br />}</pre></span><br />First, the "lineNumber" operation is called on the MethodCompiler, my interface for primary bytecode emitter. This emits bytecode for line number information based on the parsed position in the Ruby AST.<br /><br />Then we get a reference to the NextNode passed in.<br /><br />Now here's where it gets a little tricky. The "next" operation can be compiled in one of two ways. If it occurs within a normal loop, and the compiler has an appropriate jump location, it will compile as a normal Java GOTO operation. If, on the other hand, the "next" occurs within a closure (and not within an immediately-enclosing loop), we must initiate a non-local branch operation. In short, we must throw a NextJump.<br /><br />In Ruby, unlike in Java, "next" can take an optional value. In the simple case, where "next" is within a normal loop, this value is ignored. When a "next" occurs within a closure, the given value becomes the <span style="font-weight: bold;">local return</span> from that invocation of the closure. The idea is that you might write code like this, where you want to do an explicit local return from a closure rather than let the return value "fall off the end":<br /><span style=";font-family:courier new;font-size:85%;"  ><pre>def foo<br />puts "still going" while yield<br />end<br /><br />a = 0<br />foo {next false if a > 4; a += 4; true}</pre></span><br />...which simply prints "still going" four times.<br /><br />The straightforward way to compile this non-local "next" would be to evaluate the argument, construct a NextJump object, swap the two so we can call the NextJump(IRubyObject value) constructor with the given value, and then raise the exception. But that requires us to juggle values around all the time. This simple case doesn't seem like such a problem, but imagine the hundreds or thousands of nodes  the compiler will handle for a given method, all spending at least part of their time juggling stack values around. It would be a miserable waste.<br /><br />So the compiler constructs a poor-man's closure: an anonymous inner class. The inner class implements our "ClosureCallback" interface which has a single method "compile" accepting a single MethodCompiler parameter "context". This allows the non-local "next" bytecode emitter to first construct the NextJump, then ask the AST compiler to continue processing AST nodes. The compiler walks the "value" node for the "next" operation, again causing appropriate bytecode emitter calls to be made, and finally we have our value on the stack, exactly where we want it. We continue constructing the NextJump and happily toss it into the ether.<br /><br />The final line of the compileNext method initiates this process.<br /><br />So what would this look like with the closure specification in play? We'll simplify it with a function object.<br /><span style=";font-family:courier new;font-size:85%;"  ><pre>public static void compileNext(Node node, MethodCompiler context) {<br />  context.lineNumber(node.getPosition());<br /><br />  final NextNode nextNode = (NextNode) node;<br /><br />  ClosureCallback valueCallback = { MethodCompiler => context<br />      if (nextNode.getValueNode() != null) {<br />          ASTCompiler.compile(nextNode.getValueNode(), context);<br />      } else {<br />          context.loadNil();<br />      }<br />  };<br /><br />  context.pollThreadEvents();<br />  context.issueNextEvent(valueCallback);<br />}</pre></span><br />That's starting to look a little cleaner. Gone is the explicit "new"ing of a ClosureCallback anonymous class, along with the superfluous "compiler" method declaration. We're also seeing a bit of magic outside the function type: closure conversion. Our little closure that accepts a MethodCompiler parameter is being coerced into the appropriate interface type for the "valueCallback" variable.<br /><br />How about a more complicated example? Here's a much longer method from JRuby that handles "operator assignment", or any code that looks like a += b:<br /><span style=";font-family:courier new;font-size:85%;"  ><pre>public static void compileOpAsgn(Node node, MethodCompiler context) {<br />  context.lineNumber(node.getPosition());<br /><br />  // FIXME: This is a little more complicated than it needs to be;<br />  // do we see now why closures would be nice in Java?<br /><br />  final OpAsgnNode opAsgnNode = (OpAsgnNode) node;<br /><br />  final ClosureCallback receiverCallback = new ClosureCallback() {<br />      public void compile(MethodCompiler context) {<br />          ASTCompiler.compile(opAsgnNode.getReceiverNode(), context); // [recv]<br />          context.duplicateCurrentValue(); // [recv, recv]<br />      }<br />  };<br /><br />  BranchCallback doneBranch = new BranchCallback() {<br />      public void branch(MethodCompiler context) {<br />          // get rid of extra receiver, leave the variable result present<br />          context.swapValues();<br />          context.consumeCurrentValue();<br />      }<br />  };<br /><br />  // Just evaluate the value and stuff it in an argument array<br />  final ArrayCallback justEvalValue = new ArrayCallback() {<br />      public void nextValue(MethodCompiler context, Object sourceArray,<br />              int index) {<br />          compile(((Node[]) sourceArray)[index], context);<br />      }<br />  };<br /><br />  BranchCallback assignBranch = new BranchCallback() {<br />      public void branch(MethodCompiler context) {<br />          // eliminate extra value, eval new one and assign<br />          context.consumeCurrentValue();<br />          context.createObjectArray(new Node[]{opAsgnNode.getValueNode()}, justEvalValue);<br />          context.getInvocationCompiler().invokeAttrAssign(opAsgnNode.getVariableNameAsgn());<br />      }<br />  };<br /><br />  ClosureCallback receiver2Callback = new ClosureCallback() {<br />      public void compile(MethodCompiler context) {<br />          context.getInvocationCompiler().invokeDynamic(<br />                  opAsgnNode.getVariableName(), receiverCallback, null,<br />                  CallType.FUNCTIONAL, null, false);<br />      }<br />  };<br /><br />  if (opAsgnNode.getOperatorName() == "||") {<br />      // if lhs is true, don't eval rhs and assign<br />      receiver2Callback.compile(context);<br />      context.duplicateCurrentValue();<br />      context.performBooleanBranch(doneBranch, assignBranch);<br />  } else if (opAsgnNode.getOperatorName() == "&amp;&amp;") {<br />      // if lhs is true, eval rhs and assign<br />      receiver2Callback.compile(context);<br />      context.duplicateCurrentValue();<br />      context.performBooleanBranch(assignBranch, doneBranch);<br />  } else {<br />      // eval new value, call operator on old value, and assign<br />      ClosureCallback argsCallback = new ClosureCallback() {<br />          public void compile(MethodCompiler context) {<br />              context.createObjectArray(new Node[]{opAsgnNode.getValueNode()}, justEvalValue);<br />          }<br />      };<br />      context.getInvocationCompiler().invokeDynamic(<br />              opAsgnNode.getOperatorName(), receiver2Callback, argsCallback,<br />              CallType.FUNCTIONAL, null, false);<br />      context.createObjectArray(1);<br />      context.getInvocationCompiler().invokeAttrAssign(opAsgnNode.getVariableNameAsgn());<br />  }<br /><br />  context.pollThreadEvents();<br />}</pre></span><br />Gods, what a monster. And notice my snarky comment at the top about how nice closures would be (it's really there in the source, see for yourself). This method obviously needs to be refactored, but there's a key goal here that isn't addressed easily by currently-available Java syntax: the caller and the callee must cooperate to produce the final result. And in this case that means numerous closures.<br /><br />I will spare you the walkthrough on this, and I will also spare you the one or two other methods in the ASTCompiler class that are even worse. Instead, we'll jump to the endgame:<br /><span style=";font-family:courier new;font-size:85%;"  ><pre>public static void compileOpAsgn(Node node, MethodCompiler context) {<br />  context.lineNumber(node.getPosition());<br /><br />  // FIXME: This is a little more complicated than it needs to be;<br />  // do we see now why closures would be nice in Java?<br /><br />  final OpAsgnNode opAsgnNode = (OpAsgnNode) node;<br /><br />  ClosureCallback receiverCallback = { MethodCompiler context =><br />      ASTCompiler.compile(opAsgnNode.getReceiverNode(), context); // [recv]<br />      context.duplicateCurrentValue(); // [recv, recv]<br />  };<br /><br />  BranchCallback doneBranch = { MethodCompiler context =><br />      // get rid of extra receiver, leave the variable result present<br />      context.swapValues();<br />      context.consumeCurrentValue();<br />  };<br /><br />  // Just evaluate the value and stuff it in an argument array<br />  ArrayCallback justEvalValue = { MethodCompiler context, Object sourceArray, int index =><br />      compile(((Node[]) sourceArray)[index], context);<br />  };<br /><br />  BranchCallback assignBranch = { MethodCompiler context =><br />      // eliminate extra value, eval new one and assign<br />      context.consumeCurrentValue();<br />      context.createObjectArray(new Node[]{opAsgnNode.getValueNode()}, justEvalValue);<br />      context.getInvocationCompiler().invokeAttrAssign(opAsgnNode.getVariableNameAsgn());<br />  };<br /><br />  ClosureCallback receiver2Callback = { MethodCompiler context =><br />      context.getInvocationCompiler().invokeDynamic(<br />          opAsgnNode.getVariableName(), receiverCallback, null,<br />          CallType.FUNCTIONAL, null, false);<br />  };<br /><br />  // eval new value, call operator on old value, and assign<br />  ClosureCallback argsCallback = { MethodCompiler context =><br />      context.createObjectArray(new Node[]{opAsgnNode.getValueNode()}, justEvalValue);<br />  };<br /><br />  if (opAsgnNode.getOperatorName() == "||") {<br />      // if lhs is true, don't eval rhs and assign<br />      receiver2Callback.compile(context);<br />      context.duplicateCurrentValue();<br />      context.performBooleanBranch(doneBranch, assignBranch);<br />  } else if (opAsgnNode.getOperatorName() == "&amp;&amp;") {<br />      // if lhs is true, eval rhs and assign<br />      receiver2Callback.compile(context);<br />      context.duplicateCurrentValue();<br />      context.performBooleanBranch(assignBranch, doneBranch);<br />  } else {<br />      context.getInvocationCompiler().invokeDynamic(<br />              opAsgnNode.getOperatorName(), receiver2Callback, argsCallback,<br />              CallType.FUNCTIONAL, null, false);<br />      context.createObjectArray(1);<br />      context.getInvocationCompiler().invokeAttrAssign(<br />              opAsgnNode.getVariableNameAsgn());<br />  }<br /><br />  context.pollThreadEvents();<br />}</pre></span><br />There's two things I'd like you to notice here. First, it's a bit shorter as a result of the literal function objects and closure conversion. It's also a bit DRYer, which naturally plays into code reduction. Second, there's far less noise to contend with. Rather than having a minimum of five verbose lines to define a one-line closure (for example), we now have three terse ones. We've managed to tighten the focus to the lines of code we're actually interested in: the bodies of the closures.<br /><br />Of course this quick tour doesn't get into the much wider range of features that the closures proposal contains, such as non-local returns. It also doesn't show closures being invoked because with closure conversion many existing interfaces can be represented as function objects automatically.<br /><br />I'll be looking at the closure proposal a bit more closely, and time permitting I'll try to get a simple JRuby prototype compiler wired up using the techniques above. I'd recommend you give it a try too, and offer Neal your feedback.