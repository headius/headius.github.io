---
layout: post
title: 'More Compiler Strategy: Call Adapters and Stack-based Methods'
date: '2007-07-15T12:08:00.000-07:00'
author: headius
tags: 
modified_time: '2011-01-25T21:44:32.684-08:00'
blogger_id: tag:blogger.com,1999:blog-4704664917418794835.post-6663243435354574564
blogger_orig_url: http://blog.headius.com/2007/07/more-compiler-strategy-call-adapters.html
---

Compilers are hard. But not so hard as people would have you believe.<br /><br />I've committed an update that installs a CallAdapter for every compiled call site. <a href="http://svn.codehaus.org/jruby/trunk/jruby/src/org/jruby/runtime/CallAdapter.java">CallAdapter</a> is basically a small object that stores the following:<br /><ul><li>method name</li><li>method index</li><li>call type (normal, functional, variable)</li></ul>As well as providing overloaded call() implementations for 1, 2, 3, n arguments and block or no block. The basic goal with this class is to provide a call adapter (heh) that makes calling a Ruby method in compiled code as similar to (and simple as) calling any Java method.<br /><br />The end result is that while compiled class init is a bit larger (needs to load adapters for all call sites), compiled method size has dropped substantially; in compiling bench_method_dispatch.rb, the two main tests went from 4000 and 3500 bytes of code down to 1500 and 1000 bytes (roughly). And simpler code means HotSpot has a better chance to optimize.<br /><br />Here's the latest numbers for the <a href="http://svn.codehaus.org/jruby/trunk/jruby/test/bench/bench_method_dispatch_only.rb">bench_method_dispatch_only</a> test, which just measures time to call a Ruby-implemented method a bunch of times:<br /><pre>Test interpreted: 100k loops calling self's foo 100 times<br /> 2.383000   0.000000   2.383000 (  2.383000)<br /> 2.691000   0.000000   2.691000 (  2.691000)<br /> 1.775000   0.000000   1.775000 (  1.775000)<br /> 1.812000   0.000000   1.812000 (  1.812000)<br /> 1.789000   0.000000   1.789000 (  1.789000)<br /> 1.776000   0.000000   1.776000 (  1.777000)<br /> 1.809000   0.000000   1.809000 (  1.809000)<br /> 1.779000   0.000000   1.779000 (  1.781000)<br /> 1.784000   0.000000   1.784000 (  1.784000)<br /> 1.830000   0.000000   1.830000 (  1.830000)</pre>And Ruby 1.8.6 for reference:<br /><pre>Test interpreted: 100k loops calling self's foo 100 times<br />2.160000   0.000000   2.160000 (  2.188087)<br />2.220000   0.010000   2.230000 (  2.237414)<br />2.230000   0.010000   2.240000 (  2.248185)<br />2.180000   0.010000   2.190000 (  2.218540)<br />2.240000   0.010000   2.250000 (  2.259535)<br />2.220000   0.010000   2.230000 (  2.241170)<br />2.150000   0.010000   2.160000 (  2.178414)<br />2.240000   0.010000   2.250000 (  2.259772)<br />2.260000   0.000000   2.260000 (  2.285141)<br />2.230000   0.010000   2.240000 (  2.252396)</pre>Note that these are JIT numbers rather than fully precompiled numbers, so this is 100% real-world safe. Fully precompiled is just a bit faster, since there's no interpreted step or DefaultMethod wrapper to go through.<br /><br />I have also made a lot of progress on <a href="http://svn.codehaus.org/jruby/trunk/jruby/src/org/jruby/compiler/impl/StackBasedVariableCompiler.java">adapting the compiler</a> to create stack-based methods when possible. Basically, this involved <a href="http://svn.codehaus.org/jruby/trunk/jruby/src/org/jruby/compiler/ASTInspector.java">inspecting</a> the code for anything that would require access to local variables outside the body of the call. Things like <a href="http://thread.gmane.org/gmane.comp.lang.ruby.core/10957">eval, closures, etc</a>. At the moment it works well and passes all tests, but I know methods similar to gsub which modify $~ or $_ are not working right. It's disabled at the moment, pending more work, but here's the method dispatch numbers with stack-based method compilation enabled:<br /><pre>Test interpreted: 100k loops calling self's foo 100 times<br /> 1.735000   0.000000   1.735000 (  1.738000)<br /> 1.902000   0.000000   1.902000 (  1.902000)<br /> 1.078000   0.000000   1.078000 (  1.078000)<br /> 1.076000   0.000000   1.076000 (  1.076000)<br /> 1.077000   0.000000   1.077000 (  1.077000)<br /> 1.086000   0.000000   1.086000 (  1.086000)<br /> 1.077000   0.000000   1.077000 (  1.077000)<br /> 1.084000   0.000000   1.084000 (  1.084000)<br /> 1.090000   0.000000   1.090000 (  1.090000)<br /> 1.083000   0.000000   1.083000 (  1.083000)</pre>It seems very promising work. I hope I'll be able to turn it on soon.<br /><br />Oh, and for those who always need a fib fix, here's fib with both optimizations turned on:<br /><pre>~ $ jruby -J-server bench_fib_recursive.rb      <br /> 1.258000   0.000000   1.258000 (  1.258000)<br /> 0.990000   0.000000   0.990000 (  0.989000)<br /> 0.925000   0.000000   0.925000 (  0.926000)<br /> 0.927000   0.000000   0.927000 (  0.928000)<br /> 0.924000   0.000000   0.924000 (  0.925000)<br /> 0.923000   0.000000   0.923000 (  0.923000)<br /> 0.927000   0.000000   0.927000 (  0.926000)<br /> 0.928000   0.000000   0.928000 (  0.929000)</pre>And MRI:<br /><pre>~ $ ruby bench_fib_recursive.rb<br />1.760000   0.010000   1.770000 (  1.775660)<br />1.760000   0.010000   1.770000 (  1.776360)<br />1.760000   0.000000   1.760000 (  1.778413)<br />1.760000   0.010000   1.770000 (  1.776767)<br />1.760000   0.010000   1.770000 (  1.777361)<br />1.760000   0.000000   1.760000 (  1.782798)<br />1.770000   0.010000   1.780000 (  1.794562)<br />1.760000   0.010000   1.770000 (  1.777396)</pre>These numbers went down a bit because the call adapter is currently just generic code, and generic code that calls lots of different methods causes HotSpot to stumble a bit. The next step for the compiler is to generate custom call adapters for each call site that handle arity correctly (avoiding IRubyObject[] all the time) and call directly to the most-likely target methods.