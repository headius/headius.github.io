---
layout: post
title: To Keyword Or Not To Keyword
date: '2007-07-12T22:19:00.000-07:00'
author: headius
tags:
- ruby
- keywords
- methods
- jruby
modified_time: '2011-01-25T21:44:32.697-08:00'
blogger_id: tag:blogger.com,1999:blog-4704664917418794835.post-8276177780686692218
blogger_orig_url: http://blog.headius.com/2007/07/to-keyword-or-not-to-keyword.html
---

One of the most attractive aspects of Ruby is the fact that it has relatively few sacred keywords. In most cases, things you'd expect to be keywords are actually methods, and you can wrap or hook their behavior and create amazing potential.<br /><br />One perfect example of this is require. Because require is just a method, you can define your own version that wraps its behavior. This is exactly how RubyGems does its magic...rather than immediately calling the default require, it can modify load paths based on your installed gems, allowing for a dynamically-expanding load path and the pluggability we've all come to know and love.<br /><br />But all such keyword-like methods are not so well behaved. Many methods make runtime changes that are otherwise impossible to do from normal Ruby code. Most of these are on Kernel. I propose that several of these methods should actually be keywords.<br /><br /><span style="font-weight: bold;"><span style="font-style: italic;">Update:</span></span> Evan Phoenix of Rubinius (EngineYard), Wayne Kelly of Ruby.NET (Queensland University), and John Lam of IronRuby (Microsoft) have voiced their agreement on this <a href="http://blade.nagaokaut.ac.jp/cgi-bin/vframe.rb/ruby/ruby-core/11642?11599-11656">interesting ruby-core mailing list thread</a>. Have you shared your thoughts?<br /><br /><span style="font-weight: bold;">Justifying Keywords</span><br /><br />There's a number of (in my opinion, very strong) justifications for this:<br /><ol><li>Many Kernel methods manipulate runtime state in ways no other methods can. For example: local_variables requires access to the caller's variable scope; block_given? requires access to the block/iter stacks (in MRI code); eval requires access to just about everything having to do with a call; and there are others, see below.</li><li>Because many of these methods manipulate normally-inaccessible runtime state, it is not possible to implement them in Ruby code. Therefore, even if someone wanted to override them (the primary reason for them to be methods) they could not duplicate their behavior in the overridden version. Overriding only destroys their utility.</li><li>These methods are exactly the ones that complicate optimizing Ruby in all implementations, including Ruby 1.9, Rubinius, JRuby, Ruby.NET, and others. They confound a compiler's efforts to optimize calls by always leaving open questions about the behavior of a method. Will it need access to a heap-allocated scope? Will it save off a binding or the current call frame? No way to know for sure, since they're methods.</li></ol>In short, there appears to be no good reason to keep them as methods, and many reasons to make them keywords. What follows is a short list of such methods and why they ought to be keywords:<br /><ul><li>*eval - requires implicit access to the caller's binding</li><li>block_given?/iterator? - requires access to block/iter information</li><li>local_variables - requires access to caller's scope</li><li>public/private/protected - requires access to current frame's visibility</li></ul>There may be others, but these are definitely the biggest offenders. The three points above were used to compile this list, but my criteria for a keyword could be the following more straightforward points. A feature should be implemented (or converted to) a keyword if it fits either of the following criteria:<br /><ul><li>It manipulates runtime state in ways impossible from user-created code</li><li>It can't be implemented in user-created code, and therefore could not reasonably be overridden or hooked to provide additional behavior</li></ul>As an alternative, if modifications could be made to ensure these methods were not overridable, Ruby implementations could safely treat them as keywords; searching for calls to "eval" in a given context would be guaranteed to mean an eval would take place in that context.<br /><br /><span style="font-weight: bold;">What do we gain from doing all this?</span><br /><br />I can at least give a JRuby perspective. I expect others can give their perspectives.<br /><br />In JRuby, we could greatly optimize method invocations if, for example, we knew we could just use Java's local variables (on Java's stack) rather than always heap-allocating a scoping structure. We could also avoid allocating a frame or binding when they are not needed, just allowing Java's call frame to be "enough" for us. We can already detect if there are closures in a given context, which helps us learn that a heap-allocated scope will be necessary, but we can't safely detect eval, block_given?, etc. As a result of these methods-that-would-be-keywords, we're forced to set up and tear down every method in the most expensive manner.<br /><br />Other implementations&emdash;including Ruby 1.9/2.0 and Rubinius&emdash;would probably be able to make similar optimizations if we could calculate ahead of time whether these keyword operations would occur.<br /><br />For what it's worth, I may go ahead and implement JRuby's compiler to treat these methods as keywords, only falling back on the "method" behavior when we detect in the rest of the system that the keyword has been overridden. But that situation is far from ideal...we'd like to see all implementations adopt this behavior and so benefit equally.<br /><br />As an example, here's an early demonstration of the performance change in our old friend fib() when we can know ahead of time if any of these keywords are called (fib calls none of them). This example shows the performance today and the performance when we can safely just use Java local variables and scoping constructs. We could additionally omit heap-allocated frames for each call, giving a further boost.<br /><br />I've included Ruby 1.8.6 to provide a reference value.<br /><br /><br /><span style="font-weight: bold;">Current JRuby:</span><br /><pre>~ $ jruby -J-server bench_fib_recursive.rb<br />1.323000   0.000000   1.323000 (  1.323000)<br />1.118000   0.000000   1.118000 (  1.119000)<br />1.055000   0.000000   1.055000 (  1.056000)<br />1.054000   0.000000   1.054000 (  1.054000)<br />1.055000   0.000000   1.055000 (  1.054000)<br />1.055000   0.000000   1.055000 (  1.055000)<br />1.055000   0.000000   1.055000 (  1.055000)<br />1.049000   0.000000   1.049000 (  1.049000)<br /><br />~ $ jruby -J-server bench_method_dispatch_only.rb<br />Test interpreted: 100k loops calling self's foo 100 times<br />3.901000   0.000000   3.901000 (  3.901000)<br />4.468000   0.000000   4.468000 (  4.468000)<br />2.446000   0.000000   2.446000 (  2.446000)<br />2.400000   0.000000   2.400000 (  2.400000)<br />2.423000   0.000000   2.423000 (  2.423000)<br />2.397000   0.000000   2.397000 (  2.397000)<br />2.399000   0.000000   2.399000 (  2.399000)<br />2.401000   0.000000   2.401000 (  2.401000)<br />2.427000   0.000000   2.427000 (  2.428000)<br />2.403000   0.000000   2.403000 (  2.403000)</pre><span style="font-weight: bold;">Using Java's local variables instead of a heap-allocated scope:</span><br /><pre>~ $ jruby -J-server bench_fib_recursive.rb<br />2.360000   0.000000   2.360000 (  2.360000)<br />0.818000   0.000000   0.818000 (  0.818000)<br />0.775000   0.000000   0.775000 (  0.775000)<br />0.773000   0.000000   0.773000 (  0.773000)<br />0.799000   0.000000   0.799000 (  0.799000)<br />0.771000   0.000000   0.771000 (  0.771000)<br />0.776000   0.000000   0.776000 (  0.776000)<br />0.770000   0.000000   0.770000 (  0.769000)<br /><br />~ $ jruby -J-server bench_method_dispatch_only.rb<br />Test interpreted: 100k loops calling self's foo 100 times<br />3.100000   0.000000   3.100000 (  3.100000)<br />3.487000   0.000000   3.487000 (  3.487000)<br />1.705000   0.000000   1.705000 (  1.706000)<br />1.684000   0.000000   1.684000 (  1.684000)<br />1.678000   0.000000   1.678000 (  1.678000)<br />1.683000   0.000000   1.683000 (  1.683000)<br />1.679000   0.000000   1.679000 (  1.679000)<br />1.679000   0.000000   1.679000 (  1.679000)<br />1.681000   0.000000   1.681000 (  1.681000)<br />1.679000   0.000000   1.679000 (  1.679000)</pre><span style="font-weight: bold;">Ruby 1.8.6:</span><br /><pre>~ $ ruby bench_fib_recursive.rb     <br />1.760000   0.010000   1.770000 (  1.775304)<br />1.750000   0.000000   1.750000 (  1.770101)<br />1.760000   0.010000   1.770000 (  1.768833)<br />1.750000   0.010000   1.760000 (  1.782908)<br />1.750000   0.010000   1.760000 (  1.774193)<br />1.750000   0.000000   1.750000 (  1.766951)<br />1.750000   0.010000   1.760000 (  1.777814)<br />1.750000   0.010000   1.760000 (  1.782449)<br /><br />~ $ ruby bench_method_dispatch_only.rb<br />Test interpreted: 100k loops calling self's foo 100 times<br />2.240000   0.000000   2.240000 (  2.268611)<br />2.160000   0.010000   2.170000 (  2.187729)<br />2.280000   0.010000   2.290000 (  2.292342)<br />2.210000   0.010000   2.220000 (  2.250331)<br />2.190000   0.010000   2.200000 (  2.210965)<br />2.230000   0.000000   2.230000 (  2.260737)<br />2.240000   0.010000   2.250000 (  2.256210)<br />2.150000   0.010000   2.160000 (  2.173298)<br />2.250000   0.010000   2.260000 (  2.271438)<br />2.160000   0.000000   2.160000 (  2.183670)</pre><br />What do you think? Is it worth it?