---
layout: post
title: My Favorite Hotspot JVM Flags
date: '2009-01-29T07:27:00.000-08:00'
author: headius
tags: 
modified_time: '2011-01-25T21:44:31.171-08:00'
blogger_id: tag:blogger.com,1999:blog-4704664917418794835.post-605605602214424521
blogger_orig_url: http://blog.headius.com/2009/01/my-favorite-hotspot-jvm-flags.html
---

I probably start up a JVM a thousand times a day. Test runs, benchmark runs, bug confirmation, API exploration, or running actual apps. And in many of these runs, I use various JVM switches to tweak performance or investigate runtime metrics. Here's a short list of my favorite JVM switches (note these are Hotspot/OpenJDK/SunJDK switches, and may or may not work on yours. Apple JVM is basically the same, so these work).<br /><br /><span style="font-weight: bold;">The Basics</span><br /><br />Most runs will want to tweak a few simple flags:<br /><ul><li><span style="font-weight: bold;">-server</span> turns on the optimizing JIT along with a few other "server-class" settings. Generally you get the best performance out of this setting. The default VM is <span style="font-weight: bold;">-client</span>, unless you're on 64-bit (it only has <span style="font-weight: bold;">-server</span>).</li><li><span style="font-weight: bold;">-Xms</span> and <span style="font-weight: bold;">-Xmx</span> set the minimum and maximum sizes for the heap. Touted as a feature, Hotspot puts a cap on heap size to prevent it from blowing out your system. So once you figure out the max memory your app needs, you cap it to keep rogue code from impacting other apps. Use these flags like <span style="font-weight: bold;">-Xmx512M</span>, where the M stands for MB. If you don't include it, you're specifying bytes. Several flags use this format. You can also get a minor startup perf boost by setting minimum higher, since it doesn't have to grow the heap right away.</li><li><span style="font-weight: bold;">-Xshare:dump</span> can help improve startup performance on some installations. When run as root (or whatever user you have the JVM installed as) it will dump a shared-memory file to disk containing all of the core class data. This file is much faster to load then re-verifying and re-loading all the individual classes, and once in memory it's shared by all JVMs on the system. Note that <span style="font-weight: bold;">-Xshare:off</span>, <span style="font-weight: bold;">-Xshare:on</span>, <span style="font-weight: bold;">-Xshare:auto</span> set whether "Class Data Sharing" is enabled, and it's not available on the <span style="font-weight: bold;">-server</span> VM or on 64-bit systems. Mac users: you're already using Apple's version of this feature, upon which Hotspot's version is based.<br /></li></ul>There are also some basic flags for logging runtime information:<br /><ul><li><span style="font-weight: bold;">-verbose:gc</span> logs garbage collector runs and how long they're taking. I generally use this as my first tool to investigate if GC is a bottleneck for a given application.</li><li><span style="font-weight: bold;">-Xprof</span> turns on a low-impact sampling profiler. I've had Hotspot engineers recommend I "don't use this" but I still think it's a decent (albeit very blunt) tool for finding bottlenecks. Just don't use the results as anything more than a guide.</li><li><span style="font-weight: bold;">-Xrunhprof</span> turns on a higher-impact instrumenting profiler. The default invocation with no extra parameters records object allocations and high-allocation sites, which is useful for finding excess object creation. <span style="font-weight: bold;">-Xrunhprof:cpu=times</span> instruments all Java code in the JVM and records the actual CPU time calls take. I generally only use this to profile JRuby internals because it's extremely slow, but it's also much more accurate than <span style="font-weight: bold;">-Xprof</span>.</li></ul><span style="font-weight: bold;">Deeper Magic</span><br /><br />Eventually you may want to tweak deeper details of the JVM:<br /><ul><li><span style="font-weight: bold;">-XX:+UseParallelGC</span> turns on the parallel young-generation garbage collector. This is a stop-the-world collector that uses several threads to reduce pause times. There's also <span style="font-weight: bold;">-XX:+UseParallelOldGC</span> to use a parallel collector for the old generation, but it's generally only useful if you often have large numbers of old objects getting collected.</li><li><span style="font-weight: bold;">-XX:+UseConcMarkSweepGC</span> turns on the concurrent mark-sweep collector. This one runs most GC operations in parallel to your application's execution, reducing pauses significantly. It still stops the world for its compact phase, but that's usually quicker than pausing for the whole set of GC operations. This is useful if you need to reduce the impact GC has on an application run and don't mind that it's a little slower than the full stop-the-world versions. Also, you obviously would need multiple processors to see full effect. (Incidentally, if you're interested in GC tuning, you should look at <a href="http://java.sun.com/javase/technologies/hotspot/gc/gc_tuning_6.html">Java SE 6 HotSpot Virtual Machine Garbage Collection Tuning</a>. There's a lot more there.)<br /></li><li><span style="font-weight: bold;">-XX:NewRatio=#</span> sets the desired ratio of "new" to "old" generations in the heap. The defaults are 1:12 in the <span style="font-weight: bold;">-client</span> VM and 1:8 in the <span style="font-weight: bold;">-server</span> VM. You often want a higher ratio if you have a lot more transient data flowing through your application than long-lived data. For example, Ruby's high object churn often means a lower NewRatio (i.e. larger "new" versus "old") helps performance, since it prevents transient objects from getting promoted to old generations.</li><li><span style="font-weight: bold;">-XX:MaxPermSize=###M</span> sets the maximum "permanent generation" size. Hotspot is unusual in that several types of data get stored in the "permanent generation", a separate area of the heap that is only rarely (or never) garbage-collected. The list of perm-gen hosted data is a little fuzzy, but it generally contains things like class metadata, bytecode, interned strings, and so on (and this certainly varies across Hotspot versions). Because this generation is rarely or never collected, you may need to increase its size (or turn on perm-gen sweeping with a couple other flags). In JRuby especially we generate a lot of adapter bytecode, which usually demands more perm gen space.</li></ul>And there are a few more advanced logging and profiling options as well:<br /><ul><li><span style="font-weight: bold;">-XX:+PrintCompilation</span> prints out the name of each Java method Hotspot decides to JIT compile. The list will usually show a bunch of core Java class methods initially, and then turn to methods in your application. In JRuby, it eventually starts to show Ruby methods as well.</li><li><span style="font-weight: bold;">-XX:+PrintGCDetails</span> includes the data from <span style="font-weight: bold;">-verbose:gc</span> but also adds information about the size of the new generation and more accurate timings.</li><li><span style="font-weight: bold;">-XX:+TraceClassLoading</span> and <span style="font-weight: bold;">-XX:+TraceClassUnloading</span> print information class loads and unloads. Useful for investigating if you have a class leak or if old classes (like JITed Ruby methods in JRuby) are getting collected or not.</li></ul><span style="font-weight: bold;">Into The Belly</span><br /><br />Finally here's a list of the deepest options we use to investigate performance. Some of these require a debug build of the JVM, which you can download from <a href="http://download.java.net/jdk6/">java.net</a>.<br /><br />Also, some of these may require you also pass <span style="font-weight: bold;">-XX:+UnlockDiagnosticVMOptions</span> to enable them.<br /><ul><li><span style="font-weight: bold;">-XX:MaxInlineSize=#</span> sets the maximum size method Hotspot will consider for inlining. By default it's set at 35 *bytes* of bytecode (i.e. pretty small). This is largely why Hotspot really like lots of small methods; it can then decide the best way to inline them based on runtime profiling. You can bump it up, and sometimes it will produce better performance, but at some point the compilation units get large enough that many of Hotspot's optimizations are skipped. Fun to play with though.</li><li><span style="font-weight: bold;">-XX:CompileThreshold=#</span> sets the number of method invocations before Hotspot will compile a method to native code. The <span style="font-weight: bold;">-server</span> VM defaults to 10000 and <span style="font-weight: bold;">-client</span> defaults to 1500. Large numbers allow Hotspot to gather more profile data and make better decisions about inlining and optimizations. Smaller numbers reduce "warm up" time.</li><li><span style="font-weight: bold;">-XX:+LogCompilation</span> is like <span style="font-weight: bold;">-XX:+PrintCompilation</span> on steroids. It not only prints out methods that are being JITed, it also prints out why methods may be deoptimized (like if new code is loaded or a new call target is discovered) and information about which methods are being inlined. There's a caveat though: the output is seriously nasty XML without any real structure to it. I use a Sun-internal tool for rendering it in a nicer format, which I'm trying to get open-sourced. Hopefully that will happen soon. Note, this option requires <span style="font-weight: bold;">-XX:+UnlockDiagnosticVMOptions</span>.</li></ul>And finally, my current absolute favorite option, which requires a debug build of the JVM:<br /><ul><li><span style="font-weight: bold;">-XX:+PrintOptoAssembly</span> dumps to the console a log of all assembly being generated for JITed methods. The instructions are basically x86 assembly with a few Hotspot-specific instruction names that get replaced with hardware-specific instructions during the final assembly phase. In addition to the JITed assembly, this flag also shows how registers are being allocated, the probability of various branches being followed (along with multiple assembly blocks for the different paths), and information about calls back into the JVM. Outside the logging options for the final generated assembly (which requires a separate plugin) this is the best tool for discovering what optimizations are actually happening. I use this at least a couple times a week to investigate JRuby performance enhancements.</li></ul><span style="font-weight: bold;">And So Much More</span><br /><br />Hotspot has literally <a href="http://blogs.sun.com/watt/resource/jvm-options-list.html">hundreds of different flags</a> (and here's <a href="http://www.md.pp.ru/%7Eeu/jdk6options.html">another list specific to Java 6</a>), and dozens of them that might be useful to you. I may add a few more to this post as I remember them, but this list includes all those I use on a regular basis. If you're using JRuby, you can use the -J flag to pass any of these flags through to the JVM, as in <span style="font-weight: bold;">-J-XX:+PrintCompilation</span>.<br /><br />What are some of your favorite Hotspot JVM flags?<br /><br /><span style="font-style: italic;"><span style="font-weight: bold;">Update:</span></span> Another couple that commenters added or reminded me of:<br /><ul><li>Marcus Kohler commented on <span style="font-weight: bold;">-XX:+HeapDumpOnOutOfMemoryError</span>, useful if you have a slow-leaking application you can't pin down. It will dump heap information to disk whenever there's an OutOfMemoryError, allowing you to do offline analysis.</li><li>j6wbs mentioned that you can send <span style="font-weight: bold;">SIGQUIT</span> (or hit <span style="font-weight: bold;">Ctrl+Backslash</span> or <span style="font-weight: bold;">Ctrl+Break</span> in the console) to dump the current execution stack of all running threads. This is especially nice if you have a runaway app or if an app appears to have frozen.</li><li>karld offers up <span style="font-weight: bold;">-XX:OnOutOfMemoryError="mail -s 'OOM on `hostname` at `date`' whoever@example.com <<< ''"</span> as a way to send out email when there's an OutOfMemoryError. Poor-man's monitoring!</li><li>I also remembered a very important option for JRuby: <span style="font-weight: bold;">-Xbootclasspath</span> specifies classpath entries you want loaded without verification. The JVM verifies all classes it loads to ensure they don't try to dereference an object with an int, pop extra entries off the stack or push too many, and so on. This verification is part of the reason why the JVM is very stable, but it's also rather costly, and responsible for a large part of startup delay. Putting classes on the bootclasspath skips this cost, but should only be used when you know the classes have been verified many times before. In JRuby, this reduced startup time by half or more for a simple script. Use <span style="font-weight: bold;">-Xbootclasspath/a:</span> and  <span style="font-weight: bold;">-Xbootclasspath/p:</span> to append and prepend to the default bootclasspath or <span style="font-weight: bold;">-Xbootclasspath:<paths></span> to completely set your own.<br /></li></ul>