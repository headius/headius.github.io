---
layout: post
title: Duby's C Backend POC
date: '2008-03-30T08:02:00.000-07:00'
author: headius
tags: 
modified_time: '2011-01-25T21:44:31.774-08:00'
blogger_id: tag:blogger.com,1999:blog-4704664917418794835.post-5718384926252764232
blogger_orig_url: http://blog.headius.com/2008/03/duby-c-backend-poc.html
---

Late last week I wired up a quick proof-of-concept C back-end for Duby, to show that it is possible. Duby's design represents all types as symbols, which allows the type representation to vary across platforms. So in fib(), the fixnum type is represented as ":fixnum" throughout, and it can be mapped to whatever the backend decides fixnums should be. This means that, in general, code you write in Duby will type infer (for some definition of infer) and produce an AST suitable for compilation to any backend or type system. And with the appropriate plugins, like the "math" typer from my previous Duby post, you can do cool things like represent integer math as either primitive math operations or method calls against object types. But the source code remains the same.<br /><br />I also wanted to blunt some criticism I received during the first Duby prototype. It represented types as symbols, but symbols nearly identical to their eventual Java types. In order for Duby to be generally useful (in, for example, Rubinius) platform-agnostic symbolic typing is a must.<br /><br />So here's the code for my little <a href="http://svn.codehaus.org/jruby/trunk/jruby/lib/ruby/site_ruby/1.8/duby/c_compiler.rb">C backend</a> in its current state. It's pretty crude at the moment, but you can get the general idea. There's obviously work to do: it doesn't correctly insert "return" keywords, doesn't insert end-of-line semicolons everywhere appropriate (and often inserts them in totally inappropriate place), and in general doesn't produce entirely valid C code, but those are mostly minor details; the important takeaway here is that the typing and general Duby AST representation can easily be compiled this way.<br /><br />Ok then! Given a simple script:<br /><pre>def fib(n)<br />  {n =&gt; :fixnum}<br />  if n &lt; 2<br />    n<br />  else<br />    fib(n - 1) + fib(n - 2)<br />  end<br />end<br /><br />def go<br />  fib(35)<br />end</pre>We can run the C "compiler" thus:<br /><pre>jruby -rduby/plugin/math lib/ruby/site_ruby/1.8/duby/c_compiler.rb fib.rb</pre>And we get a fib.rb.c file as a result:<br /><pre>int fib(int n) {;<br />if (n &lt; 2) {n} else {fib(n - 1) + fib(n - 2)};<br />}<br /><br />;<br />int go() {fib(35)}<br /><br />;</pre>As I said, it's not the prettiest thing in the world, but I think it demonstrates that Duby should easily be able to target pretty much any backend platform you like. Fun stuff!