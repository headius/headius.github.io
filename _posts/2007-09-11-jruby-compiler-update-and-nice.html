---
layout: post
title: JRuby Compiler Update, and a Nice Peformance Milestone
date: '2007-09-11T18:45:00.000-07:00'
author: headius
tags: 
modified_time: '2011-01-25T21:44:32.551-08:00'
blogger_id: tag:blogger.com,1999:blog-4704664917418794835.post-8434649077189288921
blogger_orig_url: http://blog.headius.com/2007/09/jruby-compiler-update-and-nice.html
---

Hello again friends! It's time to update you on the status of the JRuby compiler.<br /><br /><span style="font-weight: bold;">Compiler Status</span><br /><br />I've been working feverishly for the past several weeks to get the rest of the compiler complete. Currently, it's able to handle the majority of Ruby syntax. Here's a list of the remaining language features that do not compile:<br /><ul><li>"rescue" blocks; exception handling in Ruby is rather complicated, and there's some particularly odd uses of rescue that will be a bit tricky to support with normal Java exception-handling.</li><li>"class var declaration" is not yet supported. This is when you declare a class variable (@@foo) from within the body of a class or module. This primarily affects compiling class bodies, so although it prevents AOT compilation of some scripts, it doesn't usually affect individual methods.</li><li>"opt n" execution. This is  specifying "-n" to the Ruby runtime, and it loops the provided script as though it were surrounded by "while gets(); ... end". It's useful for line-by-line processing of stdin.</li><li>"post execution" blocks. Post exe blocks are when you specify an END { ... } block somewhere in your script. These blocks are saved up and executed at the end of the script execution, regardless of where they appear in the script. They're a bit like Kernel#at_exit blocks.</li><li>"retry". Tell me friends, do you know what "retry" actually does? Retry is used within a block/closure, and it causes the method containing the closure to be re-called anew. And as an interesting quirk, the original arguments to the method are re-evaluated, so if you call foo(bar()) and a retry is triggered within foo(), bar() will get invoked again for the retried call to foo(). Weird, eh? <span style="font-weight: bold;">Update:</span> I didn't explain this well. Here's another attempt: if you have the following code:<br /><pre>def foo(x = bar()); 1.times {retry}; end</pre>And you call foo with no arguments, allowing the default argument logic to fire, retry will cause that logic to fire again and again. It's essentially re-entering the method anew with the original arguments, but causing *argument processing* to be revisited. I'm not sure why you'd want this behavior, since it could frequently result in default arguments to re-call methods that might only be valid the first time.<br /></li><li>Some non-local flow control is not yet complete. Non-local flow control happens any time you return, break, or next from within a block (when not immediately inside a normal loop construct). Much of non-local flow control is working, but I need to flush out any remaining cases that aren't running correctly.</li></ul>It's a pretty short list, eh? Obviously "rescue" is the biggest and trickiest item here. Without exception handling, it's hard to say the compiler is near completion. The complications I mentioned involve the ability to embed rescue processing into arbitrary expressions. Here's a good example:<br /><pre>a = [1, 2, (begin; raise; rescue; 3; end)]</pre>When this code is compiled, it turns into a local variable assignment. The value assigned is a literal array construction with three elements: a Fixnum 1, a Fixnum 2, and a rescued block of code. The typical way to construct the array then is to follow these steps:<br /><ol><li>Construct an array of the appropriate size</li><li>Dup the array reference<br /></li><li>Push a constant integer zero<br /></li><li>Push Fixnum 1</li><li>Insert Fixnum 1 at index zero in the array. This consumes the dup'ed array, the index, and the Fixnum1.</li><li>Dup the array reference again</li><li>Push a constant integer one<br /></li><li>Push Fixnum 2</li><li>Insert Fixnum 2</li><li>Dup the array reference again</li><li>Push a constant integer two<br /></li><li>Now it gets complicated; we must recurse in the compiler to handle the rescue block</li><li>The rescue block is compiled and a "raise" is triggered in the code</li><li>The exception raised is handled, resulting in the whole rescue leaving a Fixnum 3 on the stack</li><li>Insert the Fixnum 3</li><li>Construct a RubyArray object with the remaining object array</li></ol>Now that seems simple enough. However there's a sneaky complication at steps 13 and 14: catching an exception clears the operand stack, and the original created array, its duplicated reference, and the integer two disappear as a result. The value "returned" from the rescue section therefore has nowhere to go.<br /><br />We will likely have to solve this complication in one of two ways:<br /><ul><li>We could save off the stack when entering code that might trigger exception handling</li><li>We could put exception-handling logic in a separate method and invoke it in-place, thereby protecting our executing stack from clearage.<br /></li></ul>It remains to be seen which mechanism will work out to be simplest to compile and most performant.<br /><br /><span style="font-weight: bold;">A Nice Performance Milestone</span><br /><br />And on the topic of performance, the recent compiler work has allowed us to reach a new milestone: we now exceed Ruby 1.8.6's performance on M. Edward (Ed) Borasky's <a href="http://viewvc.rubyforge.mmmultiworks.com/cgi/viewvc.cgi/MatrixBenchmark/?root=cougar">MatrixBenchmark</a>.<br /><br />Some months back, after the <a href="http://mtnwestruby.org/">Mountain West RubyConf</a> in Salt Lake City, Ed posted an interesting blog entry where he professed a lot of confidence in JRuby's future. We emailed a bit offline, and he pointed me to this matrix benchmark he'd been using to measure the relative performance of Ruby 1.8.6 and Ruby 1.9 (YARV). I told him I'd give it a try.<br /><br />Originally, we were perhaps 50% to 100% slower than Ruby 1.8.6. This was back when hardly anything was compiling, and there had been few serious efforts to optimize the JRuby runtime. Performance slowly crept up as time went on. But as recent as a week ago, JRuby performance was still roughly 20-25% slower than 1.8.6.<br /><br />So last week, I dug into it a bit more. I turned on JRuby's JIT logging (-J-Djruby.jit.logging=true) and verbose logging (-J-Djruby.jit.logging.verbose=true) to log compiling and non-compiling methods, respectively. As it turned out, the "inverse_from" method in matrix.rb was not yet compiling...and it was where the bulk of MatrixBenchmark's work was happening.<br /><br />The final sticking point in the compiler for this method was "operator element assignment" syntax, or basically anything that looks like a[0] += 5. It's a little involved to compile; you have to retrieve the element, calculate the value, call the operator method, and reassign all in one operation. For the ||= or &&amp;= versions, you have to perform a boolean check against the element to see if you should proceed to the assignment. A good bit of compiler code, but it had to be done.<br /><br />So then, with "OpElementAsgn" compiling, it was time to re-run the numbers. And finally, finally, we were comfortably exceeding Ruby 1.8.6 performance:<br /><pre>Ruby 1.8.6:<br />Hilbert matrix of dimension 128 times its inverse = identity? true<br />586.110000   5.710000 591.820000 (781.251569)<br /><br />JRuby trunk, Java 6 server, ObjectSpace disabled:<br />Hilbert matrix of dimension 128 times its inverse = identity? true<br />372.950000   0.000000 372.950000 (372.950000)</pre>Or should I say vastly exceeding? By my calculation this is an easy 2x performance increase, and perhaps a 70% improvement just by getting this one extra method to compile.<br /><br /><span style="font-weight: bold;">On Beyond Zebra</span><br /><br />I believe we're pretty well on-target to have the compiler completed by RubyConf in November. I'm about to embark on a refactoring adventure to prepare for the stack-juggling I'll have to do to support rescue blocks. That will mean minimal progress on adding to the compiler until the end of the month, but ideally the refactoring will make it easy to get rescue compilation complete. The others are just a matter of spending some time.<br /><br />Once the JRuby compiler is complete, we will start testing in earnest against a fully pre-compiled Ruby stdlib. Along with that, we'll wire in support for pre-compiling RubyGems as they install and pre-compiling Ruby scripts as they are executed and loaded. Much of this works already in prototype form, but it waits for the completion of the compiler to go into general use.<br /><br />I also have plans for a "static" compiler for JRuby that enable compiling Ruby classes into normal, instantiable, callable, static Java classes. This would bring us on par with other compiled languages on the JVM, and allow you to directly instantiate and invoke JRuby/Ruby objects from within your Java code.<br /><br />Beyond all this work, Tom and I have been discussing a whole raft of performance improvements we could make to the underlying JRuby runtime. There's a lot more performance to be had, and it's just around the corner.<br /><br />Exciting times, friends. Exciting times.