---
layout: post
title: fork and exec on the JVM? JRuby to the Rescue!
date: '2009-05-13T23:50:00.000-07:00'
author: headius
tags: 
modified_time: '2011-01-25T21:44:30.852-08:00'
blogger_id: tag:blogger.com,1999:blog-4704664917418794835.post-624213205347835546
blogger_orig_url: http://blog.headius.com/2009/05/fork-and-exec-on-jvm-jruby-to-rescue.html
---

Today David R. MacIver pinged me in #scala and asked "headius: Presumably you guys have spent quite a lot of time trying to make things like system("vim") work correctly in JRuby and failing? i.e. I'm probably wasting my time to attempt similar?"<br /><br />My first answer was "yes", since there's no direct way to exec a program like vim (which wants a real terminal) and have it work on the JVM. The JVM's process launching gives the newly-spawned processes the child side of piped streams, which you then have to manually pump (which is what we do in JRuby's system, backtick, and exec methods). Under these circumstances, vim may start up, but it's certainly not functional.<br /><br />But then I got to thinking...if you were doing this in C, you'd fork+exec and all would be happy. But we can't fork+exec on the JVM..OR CAN WE?<br /><br />As you should know by now, JRuby ships with FFI, a library that allows you to bind any arbitrary C function in Ruby code. So getting fork+exec to work was a simple matter of writing a little Ruby code:<br /><pre>require 'ffi'<br /><br />module Exec<br /> extend FFI::Library<br /><br /> attach_function :my_exec, :execl, [:string, :string, :varargs], :int<br /> attach_function :fork, [], :int<br />end<br /><br />vim1 = '/usr/bin/vim'<br />vim2 = 'vim'<br />if Exec.fork == 0<br /> Exec.my_exec vim1, vim2, :pointer, nil<br />end<br /><br />Process.waitall</pre><br />Running that with JRuby (I tried master, David tried 1.3.0RC1, and 1.2.0 works too) brings up a full-screen vim session, just like you'd expect, and it all just works. No other JVM language can do this so quickly and easily.<br /><br />We'll probably try to generalize this into an optional library JRubyists can load (require 'jruby/real_exec' or similar) and perhaps add fork and exec to jna-posix so that the other JVM languages can have sweet, sweet process launching too.<br /><br />JRuby rocks.<div><br /></div><div><b><i>Update:</i><span class="Apple-style-span" style="font-weight: normal;"> The biggest problem with using fork+exec in this way is that you can't guarantee *nothing* happens between the fork call and the exec call. If, for example, the JVM decides to GC or move memory around, you can have a fatal crash at the JVM process level. Because of that, I don't recommend using fork + exec via FFI in JRuby, even though it's pretty cool.</span></b></div><div><br /></div><div><b><span class="Apple-style-span" style="font-weight: normal;">However, since this post I've learned of the "<a href="http://www.opengroup.org/onlinepubs/009695399/functions/posix_spawn.html">posix_spawn</a>" function available on most Unix variants. It's basically fork + exec in a single function, plus most of the typical security and IO tweaks you might do after forking and before execing. It's definitely my recommended alternative to fork+exec for JRuby, and to make that easier I've bundled it up as the "spoon" gem (gem install spoon) which provides spawn and spawnp to JRuby users directly. Here's an example session <a href="http://gist.github.com/321084">using Spoon to launch JRuby as a daemon</a>. If you just need fork+exec on the JVM, posix_spawn or the Spoon gem are the best way to do it.</span></b></div>