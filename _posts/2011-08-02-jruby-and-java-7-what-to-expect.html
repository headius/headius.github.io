---
layout: post
title: 'JRuby and Java 7: What to Expect'
date: '2011-08-02T10:27:00.000-07:00'
author: headius
tags: 
modified_time: '2011-08-02T21:03:30.529-07:00'
blogger_id: tag:blogger.com,1999:blog-4704664917418794835.post-5727286770456885866
blogger_orig_url: http://blog.headius.com/2011/08/jruby-and-java-7-what-to-expect.html
---

Java 7 has landed, with a modest set of new features and a few major improvements as well. What can you expect from JRuby running on Java 7?<br /><br /><b>What's In Java 7</b><br /><b><br /></b><br />The biggest changes in Java 7 are not related to the Java language at all. Sure, there's the "project coin" enhancements to the Java language, which add some exception-handling shortcuts, new literals for numbers, arrays, hashes, the oft-requested "strings in switch" support, and a few other things. But they're modest incremental changes; the real revolution is at the JVM and JDK level.<br /><br /><b>Invokedynamic</b><br /><b><br /></b><br />The most important change in Java 7 is the incorporation of a new bytecode -- invokedynamic -- and an API for building chains of "method handles" to back that bytecode up.<br /><br />You can look at invokedynamic as a way for JVM users to communicate directly with the optimizing backend of the JVM. Method handles act as both function pointers and as function combinators, allowing a built-in way to construct a call protocol flow from a caller to a callee. You can move arguments around, insert new arguments, process existing arguments and return values, catch exceptions, and perform fast guarded branches between two (or more) paths. The invokedynamic bytecode itself provides a bytecode-level hook to which you attach your method handle chain, with the assumption that the JVM can optimize that chain directly into the invokedynamic caller.<br /><br />The tl;dr is that invokedynamic makes it possible for the JVM to see through complicated method call logic, such as that found in dynamic languages, and optimize that logic like it would for regular "static" calls.<br /><br />JRuby's master branch already takes heavy advantage of invokedynamic, by routing most Ruby calls through invokedynamic operations. For simple paths and those that have been optimized by the Hotspot guys (Hotspot is the VM at the core of OpenJDK), invokedynamic often provides performance improvements of 150-200%, with work ongoing to make it even faster. Other paths may not be as well-optimized by the "dot zero" version of OpenJDK 7, so there's opportunity to improve them.<br /><br />Because JRuby is already well along the road to utilizing invokedynamic, you can try it out today.<br /><br /><ol><li>Build your own JRuby from master or grab a snapshot from&nbsp;<a href="http://ci.jruby.org/snapshots">our CI server</a>.</li><li>Grab a build of <a href="http://www.oracle.com/technetwork/java/javase/downloads/java-se-jdk-7-download-432154.html">OpenJDK 7 from Oracle</a> (or a build of <a href="http://code.google.com/p/openjdk-osx-build/">OpenJDK 7 for OS X</a>).</li><li>Point JAVA_HOME at the new JDK and try out JRuby!</li></ol><div>We're looking for small benchmarks that show the performance of invokedynamic (good or bad), so please contact me, the JRuby team, or the JRuby users mailing list with your reports from the field. Also, feel free to open performance bugs on the <a href="http://bugs.jruby.org/">JRuby bug tracker</a> if invokedynamic performs <b>worse</b>&nbsp;than non-invokedynamic. Pass&nbsp;-Xcompile.invokedynamic=false to JRuby to revert to the old non-invokedynamic logic.</div><div><br /></div><div><b>NIO.2</b></div><div><b><br /></b></div><div>NIO is Java's "New IO" APIs, a set of wrappers around low-level file-descriptor logic and memory buffers. NIO has been around since Java 1.4, but the recent update -- dubbed <a href="http://nio.2/">NIO.2</a> -- brings a sorely-needed update to the functionality provided:</div><div><ul><li>Filesystem operations (like symlinks, permissions, etc) are now almost all available through NIO.2's filesystem APIs. This also includes standard, cross-platform support for filesystem events, such as watching a directory for changes (using efficient OS-level operations, rather than polling).</li><li>File and directory walking now comes with considerably less overhead and more options for filtering directory lists <b>before</b>&nbsp;handing filenames off to user code. There's also support for opening a directory directly and walking its contents as you would a file.</li><li>Most IO channel types now have asynchronous versions. Asynchronous in this case means "punt my IO operation to a built-in thread pool", with subsequent code checking on the status of those operations and getting results from a "future" handle.</li></ul><div>For JRuby, the new IO APIs will mean we can support more filesystem operations across platforms without resorting to native code. It will also provide JRuby users a means of handling filesystem events and asynchronous IO operations without using a platform-specific library. We have not yet started adding NIO.2 support to JRuby's core classes, but that will come soon.</div></div><div><br /></div><div><b>General Improvements</b></div><div><b><br /></b></div><div>There's lots of smaller, less flashy changes in OpenJDK that also appear to help JRuby.</div><div><br /></div><div>Even without invokedynamic, the latest OpenJDK 7 builds usually perform better than OpenJDK 6. Some benchmarks have proven to be as much as 2x faster, just by upgrading the JVM! General perf improvements will be more modest, but in almost every case we've tested OpenJDK 7 definitely performs better.</div><div><br /></div><div>The release of OpenJDK 7 also brings improvements to the "tiered" compilation mode. Tiered compilation aims to merge the benefits of the "client" mode (fast startup) with those of the "server" mode (maximum peak performance). You can turn on tiered compilation using -XX:+TieredCompilation (in JAVA_OPTS or at the "java" command line, or prefixed with -J when passed to JRuby). We're looking for user reports about how well "tiered" mode works, too.</div><div><br /></div><div>This general improvement means that even JRuby 1.6.x users can take advantage of OpenJDK 7 today, with the promise of even bigger improvements in JRuby 1.7 (our target release for pervasive invokedynamic support).</div><div><br /></div><div><b>Consistency</b></div><div><b><br /></b></div><div>As with previous Java releases, a great deal of care has been taken to ensure existing applications work properly. That applies as well to Java 7. We have been testing against Java 7 for over a year, on and off, and recently started running tests "green" with even heavy invokedynamic use.</div><div><br /></div><div>We have made no major Java 7-specific fixes in JRuby...it should generally "just work".</div><div><br /></div><div><b>Let Us Know!</b></div><div><b><br /></b></div><div>As always, we really want to hear from you bleeding-edge users that are playing around with JRuby on Java 7. Please don't be shy...let us know how it works for you!<br /><br /><i style="font-weight: bold;">Update:</i>&nbsp;The Hotspot guys have been helping me find invokedynamic bottlenecks in a few JRuby microbenchmarks, and discovered that a flaw in invokedynamic was causing <b>too much</b>&nbsp;code to inline, forcing out more important optimizations. The details belong in another post, but they offered me a long Hotspot flag to accomplish basically what their fix does:&nbsp;<span class="Apple-style-span" style="font-family: 'Bitstream Vera Sans Mono', Courier, monospace; font-size: 12px; line-height: 16px; white-space: pre;">-XX:CompileCommand=dontinline,org.jruby.runtime.invokedynamic.InvokeDynamicSupport::invocationFallback</span>&nbsp;... With this flag, performance on e.g. "tak" easily beats stock JRuby (see the third benchmark run here: <a href="https://gist.github.com/1121880">https://gist.github.com/1121880</a>).<br /><br />I would recommend trying this flag if you are finding invokedynamic slowdowns in JRuby.<br /></div>