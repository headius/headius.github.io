---
layout: post
title: 'Groovy in Ruby: Implement Interface with a Map'
date: '2007-12-05T17:07:00.000-08:00'
author: headius
tags: 
modified_time: '2011-01-25T21:44:32.115-08:00'
blogger_id: tag:blogger.com,1999:blog-4704664917418794835.post-3802117822408733532
blogger_orig_url: http://blog.headius.com/2007/12/groovy-in-ruby-implement-interface-with.html
---

Some of you may know I participate in the Groovy community as well. I'm hoping to start contributing some development time to the Groovy codebase, but for now I've mostly been monitoring their progress. One thing the Groovy team has more experience with is integrating with Java.<br /><br />Now if you ask the Groovy team, they'll make some claim like "it's all Java objects" or "Groovy integrates seamlessly with Java" but neither of those are entirely true. Groovy does integrate extremely well with Java, but it's because of a number of features they've added over time to make it so...many of them not directly part of the Groovy language but features of their core libraries and portions of their runtime.<br /><br />Since Ruby and Groovy seem to be the two most popular (or noisiest) non-Java JVM languages these days, I thought I'd start a series of posts showing how to add Groovy features missing from Ruby to JRuby. But there's a catch: I'll use only Ruby code to do this, and what I show will work on any unmodified JRuby release. That's the beauty of Ruby: the language is so flexible and fluid, you can implement many features from other languages without ever modifying the implementation.<br /><br />First up, Groovy's ability to implement an interface from a Map.<br /><pre>1. impl = [<br />2.   i: 10,<br />3.   hasNext: { impl.i &gt; 0 },<br />4.   next: { impl.i-- },<br />5. ]<br />6. iter = impl as Iterator<br />7. while ( iter.hasNext() )<br />8.   println iter.next()</pre>Ok, this is Groovy code. The brackety thing assigned to 'impl' shows Groovy's literal Map syntax (a Hash to you Rubyists). Instead of providing literal strings for the keys, Groovy automatically turns whatever token is in the key position into a Java String. So 'i' becomes a String key referencing 10, 'hasNext' becomes a String key referencing a block of code that checks if impl.i is greater than zero, and so on.<br /><br />The magic comes on line 6, where the newly-constructed Map is coerced into a java.util.Iterator implementation. The resulting object can then be passed to other code that expects Iterator, such as the while loop on lines 7 and 8, and the values from the Map will be used as the code for the implemented methods.<br /><br />To be honest, I find this feature a bit weird. In JRuby, you can implement a given interface on any class, add methods to that class at will, and get most of this functionality without ever touching a Hash object. But it's pretty simple to implement this in JRuby:<br /><pre>1. module InvokableHash<br />2.   def as(java_ifc)<br />3.     java_ifc.impl {|name, *args| self[name].call(*args)}<br />4.   end<br />5. end</pre>Here we have one of Ruby's wonderful modules, which I appreciate more each day. This InvokableHash module provides only a single method 'as' which accepts a Java interface type and produces an implementation of that type that uses the contents of hash keys to implement the methods. That's really all there is to it. So by reopening the Hash class, we gain this functionality:<br /><pre>1. class Hash<br />2.   include InvokableHash<br />3. end</pre>And we're done! Let's see the fruits of our labor in action:<br /><pre>1. impl = {<br />2.   :i =&gt; 10,<br />3.   :hasNext =&gt; proc { impl[:i] &gt; 0 },<br />4.   :next =&gt; proc { impl[:i] -= 1 }<br />5. }<br />6. iter = impl.as java.util.Iterator<br />7. while (iter.hasNext)<br />8.   puts iter.next<br />9. end</pre>Our final Ruby code looks roughly like the Groovy code. On lines 1 through 5 we construct a literal Hash. Notice that instead of automatically turning identifier tokens into Strings, Ruby uses the exact object you specify for the key, and so here we use Ruby Symbols as our hash keys (they're roughly like interned Strings, and highly recommended for hash keys). On line 6, we coerce our Hash into an Iterator instance (and we could have imported Iterator above to avoid the long name). And then lines 7 through 9 use the new Iterator impl in exactly the same way as the Groovy code.<br /><br />You've gotta love a language this flexible, especially with JRuby's magic Java integration features to back it up.