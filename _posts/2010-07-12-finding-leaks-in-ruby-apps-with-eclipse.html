---
layout: post
title: Finding Leaks in Ruby Apps with Eclipse Memory Analyzer
date: '2010-07-12T09:35:00.000-07:00'
author: headius
tags: 
modified_time: '2011-01-25T21:44:30.391-08:00'
thumbnail: http://3.bp.blogspot.com/_HWobMsJuRHc/TDtFCmrPcmI/AAAAAAAAAFw/5IUkJUka6Eo/s72-c/Screen+shot+2010-07-12+at+11.34.47+AM.png
blogger_id: tag:blogger.com,1999:blog-4704664917418794835.post-7139510682071755456
blogger_orig_url: http://blog.headius.com/2010/07/finding-leaks-in-ruby-apps-with-eclipse.html
---

After my post on <a href="http://blog.headius.com/2010/07/browsing-memory-jruby-way.html">Browsing Memory the JRuby Way</a>, one commenter and several other folks suggested I actually show using Eclipse MAT with JRuby. So without further ado...<br /><br />The <a href="http://www.eclipse.org/mat/">Eclipse Memory Analyzer</a>, like many Eclipse-based applications, starts up with a "for dummies" page linking to various actions.<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://3.bp.blogspot.com/_HWobMsJuRHc/TDtFCmrPcmI/AAAAAAAAAFw/5IUkJUka6Eo/s1600/Screen+shot+2010-07-12+at+11.34.47+AM.png"><img style="margin:0 10px 10px 0;cursor:pointer; cursor:hand;width: 400px; height: 301px;" src="http://3.bp.blogspot.com/_HWobMsJuRHc/TDtFCmrPcmI/AAAAAAAAAFw/5IUkJUka6Eo/s400/Screen+shot+2010-07-12+at+11.34.47+AM.png" border="0" alt="" id="BLOGGER_PHOTO_ID_5493060081552421474" /></a><br /><br />The most interesting use of MAT is to analyze a heap dump in a bit more interactive way than with the "jhat" tool. The analysis supports the "jmap" dump format, so we'll proceed to get a jmap dump of a "leaky" Rails application.<br /><br />I've added this controller to a simple application:<br /><br /><pre>class LeakyController &lt; ApplicationController<br />  class MyData<br />    def initialize(params)<br />      @params = params<br />    end<br />  end<br />  <br />  LEAKING_ARRAY = {}<br />  def index<br />    LEAKING_ARRAY[Time.now] = MyData.new(params)<br />    render :text =&gt; "There are #{LEAKING_ARRAY.size} elements now!"<br />  end<br />end</pre><br /><br />Some genius has decided to save all recent request parameters into a constant on the LeakyController, keyed by time, wrapped in a custom type, and never cleaned out. Perhaps this was done temporarily for debugging, or perhaps we have a moron on staff. Either way, we need to find this problem and fix it.<br /><br />We'll run this application and crank 10000 requests through the /leaky index, so the final request should output "There are 10000 elements now!"<br /><br /><pre>~ ➔ ab -n 10000 http://localhost:3000/leaky<br />This is ApacheBench, Version 2.3 &lt;$Revision: 655654 $&gt;<br />Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/<br />Licensed to The Apache Software Foundation, http://www.apache.org/<br /><br />Benchmarking localhost (be patient)<br />Completed 1000 requests<br />Completed 2000 requests<br />...</pre><br /><br />After 10000 requests have completed, we notice this application seems to grow and grow until it maxes out the heap (JRuby, being on the JVM, automatically limits heap sizes for you). Let's start by using jmap to investigate the problem.<br /><br /><pre>~ ➔ jps -l<br />61976 org/jruby/Main<br />61999 sun.tools.jps.Jps<br />61837<br /><br />~ ➔ jmap -histo 61976 | grep " ruby\." | head -5<br /> 37:         11685         280440  ruby.TZInfo.TimezoneTransitionInfo<br /> 40:         10000         240000  ruby.LeakyController.MyData<br />133:           970          23280  ruby.Gem.Version<br />137:           914          21936  ruby.Gem.Requirement<br />170:           592          14208  ruby.TZInfo.TimezoneOffsetInfo</pre><br /><br />We can see our old friend TimezoneTransitionInfo in there, but of course we've learned to accept that one. But what's this LeakyController::MyData object we've apparently got 10000 instances of? Where are they coming from? Who's holding on to them?<br /><br />At this point, we can proceed to get a memory dump and move over to MAT, or have MAT acquire and open the dump in one shot, similar to VisualVM. Let's have MAT do it for us.<br /><br /><span style="font-weight:bold;">Getting Our Heap Into MAT</span><br /><br />(Caveat: While preparing this post, I discovered that the jmap tool for the current OS X Java 6 (build 1.6.0_20-b02-279-10M3065) is not properly dumping all information. As a result, many fields and objects don't show up in dump analysis tools like MAT. Fortunately, there's a way out; on OS X, you can grab Soylatte or OpenJDK builds from various sources that work properly. In my case, I'm using a local build of OpenJDK 7.)<br /><br />From the File menu, we select Acquire Heap Dump.<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://4.bp.blogspot.com/_HWobMsJuRHc/TDtK89bP55I/AAAAAAAAAF4/p83BuCe9SYc/s1600/Screen+shot+2010-07-12+at+12.03.03+PM.png"><img style="margin:0 10px 10px 0;cursor:pointer; cursor:hand;width: 214px; height: 108px;" src="http://4.bp.blogspot.com/_HWobMsJuRHc/TDtK89bP55I/AAAAAAAAAF4/p83BuCe9SYc/s400/Screen+shot+2010-07-12+at+12.03.03+PM.png" border="0" alt="" id="BLOGGER_PHOTO_ID_5493066581649909650" /></a><br /><br />The resulting dialog should be familiar, since it lists the same JVM processes the "jps" command listed above. (If you had to specify a specific JDK home, like me, you'll need to click the "Configure" button and set the "jdkhome" flag" for "HPROF jmap dump provider".)<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://3.bp.blogspot.com/_HWobMsJuRHc/TDtLNsHLDkI/AAAAAAAAAGA/01GRelhWa6Q/s1600/Screen+shot+2010-07-12+at+12.04.08+PM.png"><img style="margin:0 10px 10px 0;cursor:pointer; cursor:hand;width: 400px; height: 305px;" src="http://3.bp.blogspot.com/_HWobMsJuRHc/TDtLNsHLDkI/AAAAAAAAAGA/01GRelhWa6Q/s400/Screen+shot+2010-07-12+at+12.04.08+PM.png" border="0" alt="" id="BLOGGER_PHOTO_ID_5493066869060079170" /></a><br /><br />We'll pick our Rails instance (pid 61976) and proceed.<br /><br />MAT connects to the process, pulls a heap dump to disk, and immediately proceeds to parse and open it.<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://1.bp.blogspot.com/_HWobMsJuRHc/TDtLm7ZwVWI/AAAAAAAAAGI/OumtSe-wDso/s1600/Screen+shot+2010-07-12+at+12.05.49+PM.png"><img style="margin:0 10px 10px 0;cursor:pointer; cursor:hand;width: 400px; height: 162px;" src="http://1.bp.blogspot.com/_HWobMsJuRHc/TDtLm7ZwVWI/AAAAAAAAAGI/OumtSe-wDso/s400/Screen+shot+2010-07-12+at+12.05.49+PM.png" border="0" alt="" id="BLOGGER_PHOTO_ID_5493067302661281122" /></a><br /><br />Once it has completed parsing, we're presented with a few different paths to follow.<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://1.bp.blogspot.com/_HWobMsJuRHc/TDtL0xLEGgI/AAAAAAAAAGQ/FGfWfCbxaCY/s1600/Screen+shot+2010-07-12+at+12.07.12+PM.png"><img style="margin:0 10px 10px 0;cursor:pointer; cursor:hand;width: 400px; height: 321px;" src="http://1.bp.blogspot.com/_HWobMsJuRHc/TDtL0xLEGgI/AAAAAAAAAGQ/FGfWfCbxaCY/s400/Screen+shot+2010-07-12+at+12.07.12+PM.png" border="0" alt="" id="BLOGGER_PHOTO_ID_5493067540433476098" /></a><br /><br />On other days, we might be interested in doing some component-by-component browsing to look for fat objects or minor leaks, or we might want to revisit the results of previous analyses against this heap. But today, we really need to figure out this MyData leak, so we'll run the Leak Suspects Report.<br /><br /><span style="font-weight:bold;">Leak Suspects?</span><br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://4.bp.blogspot.com/_HWobMsJuRHc/TDtMXrPI-NI/AAAAAAAAAGY/-NmvIZKNbQo/s1600/Screen+shot+2010-07-12+at+12.09.31+PM.png"><img style="margin:0 10px 10px 0;cursor:pointer; cursor:hand;width: 400px; height: 162px;" src="http://4.bp.blogspot.com/_HWobMsJuRHc/TDtMXrPI-NI/AAAAAAAAAGY/-NmvIZKNbQo/s400/Screen+shot+2010-07-12+at+12.09.31+PM.png" border="0" alt="" id="BLOGGER_PHOTO_ID_5493068140135381202" /></a><br /><br />Are you kidding? A tool that can search out and report possible leaks in a running system? Yes, Virginia, there is a Santa Claus!<br /><br />This is the good side of the "plague of choices" we have on the JVM. Because there's so many tools for almost every basic purpose (like the dozen – at least – memory inspection tools), tool developers have moved on to more specific needs like leak analysis. MAT is my favorite tool for leak-hunting (and it uses less memory than jhat for heap-browsing, which is great for larger dumps).<br /><br />Once MAT has finished chewing on our heap, it presents a pie chart of possible leak suspects. The logic used essentially seeks out data structures whose accumulated size is large in comparison to the rest of the heap. In this case, MAT has identified three suspects that in total comprise over half of the live heap data.<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://4.bp.blogspot.com/_HWobMsJuRHc/TDtOJW0lylI/AAAAAAAAAGo/H6s9-Rjt0gU/s1600/Screen+shot+2010-07-12+at+12.15.12+PM.png"><img style="margin:0 10px 10px 0;cursor:pointer; cursor:hand;width: 400px; height: 275px;" src="http://4.bp.blogspot.com/_HWobMsJuRHc/TDtOJW0lylI/AAAAAAAAAGo/H6s9-Rjt0gU/s400/Screen+shot+2010-07-12+at+12.15.12+PM.png" border="0" alt="" id="BLOGGER_PHOTO_ID_5493070093160401490" /></a><br /><br />Scrolling down we start to get details about these leak candidates.<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://3.bp.blogspot.com/_HWobMsJuRHc/TDtOnTP8PVI/AAAAAAAAAGw/hmmT_-41h8I/s1600/Screen+shot+2010-07-12+at+12.18.37+PM.png"><img style="margin:0 10px 10px 0;cursor:pointer; cursor:hand;width: 352px; height: 400px;" src="http://3.bp.blogspot.com/_HWobMsJuRHc/TDtOnTP8PVI/AAAAAAAAAGw/hmmT_-41h8I/s400/Screen+shot+2010-07-12+at+12.18.37+PM.png" border="0" alt="" id="BLOGGER_PHOTO_ID_5493070607597452626" /></a><br /><br />So there's a Hash, a Module, and 711 Class objects in our list of suspects. The Class objects are probably just loaded classes, since the JRuby core classes and additional classes loaded from Rails and its dependent libraries will easily number in the hundreds. We'll ignore that one for now. There's also an unusually large Module taking up almost 4MB of memory. We'll come back to that.<br /><br />The Hash seems like the most likely candidate. Let's expand that.<br /><br />The first new block of information gives us a list of "shortest paths" to the "accumulation point", or the point at which all this potentially-leaking data is gathering. There's more to this in the actual application, but I'm showing the top of the "path" here.<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://2.bp.blogspot.com/_HWobMsJuRHc/TDtP2ptyTsI/AAAAAAAAAG4/ePbY9kMrYos/s1600/Screen+shot+2010-07-12+at+12.22.36+PM.png"><img style="margin:0 10px 10px 0;cursor:pointer; cursor:hand;width: 400px; height: 314px;" src="http://2.bp.blogspot.com/_HWobMsJuRHc/TDtP2ptyTsI/AAAAAAAAAG4/ePbY9kMrYos/s400/Screen+shot+2010-07-12+at+12.22.36+PM.png" border="0" alt="" id="BLOGGER_PHOTO_ID_5493071970837876418" /></a><br /><br />At the top of this list, we see the RubyHash object originally reported as a suspect, and a tree of objects that lead to it. In this case, we go from the Hash itself into a ConcurrentHashMap (note that we're hiding nothing here; you can literally browse anything in memory) which in turn is referenced by the "constants" field of a Class. So already we know that this hash is being referenced in some class's constant table. Pretty cool, eh?<br /><br />Let's make sure we've got the right Hash and not some harmless data structure inside Rails. If we scroll down a bit more, we see a listing of all the objects this Hash has accumulated. Let's see what's in there.<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://1.bp.blogspot.com/_HWobMsJuRHc/TDtQx_pMw6I/AAAAAAAAAHA/XuiaB_f65f8/s1600/Screen+shot+2010-07-12+at+12.27.55+PM.png"><img style="margin:0 10px 10px 0;cursor:pointer; cursor:hand;width: 400px; height: 150px;" src="http://1.bp.blogspot.com/_HWobMsJuRHc/TDtQx_pMw6I/AAAAAAAAAHA/XuiaB_f65f8/s400/Screen+shot+2010-07-12+at+12.27.55+PM.png" border="0" alt="" id="BLOGGER_PHOTO_ID_5493072990336500642" /></a><br /><br />Ok, so it's a hashtable structure with a table of entries. Can we get more out of this?<br /><br />Of course like most of these tools, just about everything is clickable. We can dive into one of the hash entries and see what's in there. Clicking on an entry gives us several new ways to display the downstream objects we've managed to aggregate. In this case, we'll just do "List Objects", and the suboption "With Outgoing References" for downstream data.<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://3.bp.blogspot.com/_HWobMsJuRHc/TDtSjlWP7wI/AAAAAAAAAHQ/3PKVakLYux8/s1600/Screen+shot+2010-07-12+at+12.35.15+PM.png"><img style="margin:0 10px 10px 0;cursor:pointer; cursor:hand;width: 400px; height: 192px;" src="http://3.bp.blogspot.com/_HWobMsJuRHc/TDtSjlWP7wI/AAAAAAAAAHQ/3PKVakLYux8/s400/Screen+shot+2010-07-12+at+12.35.15+PM.png" border="0" alt=""id="BLOGGER_PHOTO_ID_5493074941782781698" /></a><br /><br />Now finally in the resulting view of this particular RubyHashEntry, we can see that our MyData object is happily tucked away inside.<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://1.bp.blogspot.com/_HWobMsJuRHc/TDtTmzCEicI/AAAAAAAAAHY/css1X69o8CQ/s1600/Screen+shot+2010-07-12+at+12.40.23+PM.png"><img style="margin:0 10px 10px 0;cursor:pointer; cursor:hand;width: 400px; height: 162px;" src="http://1.bp.blogspot.com/_HWobMsJuRHc/TDtTmzCEicI/AAAAAAAAAHY/css1X69o8CQ/s400/Screen+shot+2010-07-12+at+12.40.23+PM.png" border="0" alt=""id="BLOGGER_PHOTO_ID_5493076096507480514" /></a><br /><br />Ok, so we definitely have the right data structure. Not only that, but we can see that the entry's "key" is a Time object (org.jruby.RubyTime). Let's go back to the "Shortest Paths" view and examine the ConcurrentHashMap entry that's holding this Hash object. Each entry in this hash maps a constant name to a value, so we should be able to see which constant is holding the leaking references.<br /><br />(At this point you'll see the side effects of my switch to OpenJDK 7; the memory addresses have changed, but the structure is the same.)<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://4.bp.blogspot.com/_HWobMsJuRHc/TDtkD1XjmYI/AAAAAAAAAHo/BwpelWVULt8/s1600/Screen+shot+2010-07-12+at+1.50.21+PM.png"><img style="margin:0 10px 10px 0;cursor:pointer; cursor:hand;width: 400px; height: 69px;" src="http://4.bp.blogspot.com/_HWobMsJuRHc/TDtkD1XjmYI/AAAAAAAAAHo/BwpelWVULt8/s400/Screen+shot+2010-07-12+at+1.50.21+PM.png" border="0" alt=""id="BLOGGER_PHOTO_ID_5493094187536718210" /></a><br /><br />We'll do another "List Objects" "with outgoing references" against the the HashEntry object immediately referencing our RubyHash.<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://3.bp.blogspot.com/_HWobMsJuRHc/TDtkjEPNbyI/AAAAAAAAAHw/2VrgnFtTjmA/s1600/Screen+shot+2010-07-12+at+1.52.24+PM.png"><img style="margin:0 10px 10px 0;cursor:pointer; cursor:hand;width: 400px; height: 88px;" src="http://3.bp.blogspot.com/_HWobMsJuRHc/TDtkjEPNbyI/AAAAAAAAAHw/2VrgnFtTjmA/s400/Screen+shot+2010-07-12+at+1.52.24+PM.png" border="0" alt=""id="BLOGGER_PHOTO_ID_5493094724104187682" /></a><br /><br />And there it is! In the "key" field of the HashEntry, we see our constant name "LEAKING_ARRAY".<br /><br /><span style="font-weight:bold;">What About That Module?</span><br /><br />Oh yeah, what about that Module that showed up in the leak suspects? It was responsible for almost 4MB of the heap. Let's go back and check it out.<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://2.bp.blogspot.com/_HWobMsJuRHc/TDtonR3TZJI/AAAAAAAAAH4/nBWwgFRGrb8/s1600/Screen+shot+2010-07-12+at+2.09.56+PM.png"><img style="margin:0 10px 10px 0;cursor:pointer; cursor:hand;width: 400px; height: 182px;" src="http://2.bp.blogspot.com/_HWobMsJuRHc/TDtonR3TZJI/AAAAAAAAAH4/nBWwgFRGrb8/s400/Screen+shot+2010-07-12+at+2.09.56+PM.png" border="0" alt=""id="BLOGGER_PHOTO_ID_5493099194527999122" /></a><br /><br />A-ha! Eclipse MAT has flagged the Gem module as being a potential leak suspect. But why? Let's go back to the suspect report and look at the Accumulated Objects by Class table, toward the bottom.<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://2.bp.blogspot.com/_HWobMsJuRHc/TDtrQmAy46I/AAAAAAAAAII/GMwqC_my1MA/s1600/Screen+shot+2010-07-12+at+2.21.12+PM.png"><img style="margin:0 10px 10px 0;cursor:pointer; cursor:hand;width: 400px; height: 110px;" src="http://2.bp.blogspot.com/_HWobMsJuRHc/TDtrQmAy46I/AAAAAAAAAII/GMwqC_my1MA/s400/Screen+shot+2010-07-12+at+2.21.12+PM.png" border="0" alt=""id="BLOGGER_PHOTO_ID_5493102103334413218" /></a><br /><br />Ok, so the Gem module eventually references nearly <strike>6000</strike> Gem::Specification objects, which makes up the bulk of our 3.8MB. <strike>I guarantee I don't have 6000 gem versions installed.</strike> Perhaps that's something that RubyGems should endeavor to fix? Perhaps we've just used JRuby and Eclipse MAT to discover either a leak or wasteful memory use in RubyGems?<br /><br />Evan Phoenix pointed out that I misread the columns. It's actually 249 Specification objects, their "self" size is almost 6000 bytes, and their "retained" size is 3.8MB. But that gives me an opportunity to show off another feature of MAT: Customized Retained Set calculation.<br /><br />In this case, the retained size seems a bit suspect. Could there really be 3.8MB of data kept alive by Gem::Specification objects? It seems like a bit much, to be sure, but digging through the tree of references from the Gem module down shows there's several references to classes and modules, which in turn reference constant tables, method tables, and so on. How can we filter out that extra noise?<br /><br />First we'll return to the view of the Gem module (two screenshots up) by going back to leak suspect #2, expanding "Shortest Paths". The topmost RubyModule in that list is the Gem module, so we're all set to calculate a Customized Retained Set.<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://2.bp.blogspot.com/_HWobMsJuRHc/TDuxnysBvPI/AAAAAAAAAIQ/zCm-yA_omcE/s1600/Screen+shot+2010-07-12+at+7.21.11+PM.png"><img style="margin:0 10px 10px 0;cursor:pointer; cursor:hand;width: 400px; height: 147px;" src="http://2.bp.blogspot.com/_HWobMsJuRHc/TDuxnysBvPI/AAAAAAAAAIQ/zCm-yA_omcE/s400/Screen+shot+2010-07-12+at+7.21.11+PM.png" border="0" alt=""id="BLOGGER_PHOTO_ID_5493179467687902450" /></a><br /><br />The resulting dialog provides a list of options through which you can specify classes or fields to ignore when calculating the retained set from a given starting point. In this case, it's simple enough to filter out org.jruby.RubyClass and org.jruby.RubyModule, so that references from Gem::Specification back into the class/module hierarchy don't get included in calculations.<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://3.bp.blogspot.com/_HWobMsJuRHc/TDuydqIbWlI/AAAAAAAAAIY/Sa1Bz5PcsYo/s1600/Screen+shot+2010-07-12+at+7.24.50+PM.png"><img style="margin:0 10px 10px 0;cursor:pointer; cursor:hand;width: 400px; height: 315px;" src="http://3.bp.blogspot.com/_HWobMsJuRHc/TDuydqIbWlI/AAAAAAAAAIY/Sa1Bz5PcsYo/s400/Screen+shot+2010-07-12+at+7.24.50+PM.png" border="0" alt=""id="BLOGGER_PHOTO_ID_5493180393104038482" /></a><br /><br />Which results in a similar view to those we've seen, but with objects sorted by retained heap.<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://4.bp.blogspot.com/_HWobMsJuRHc/TDu1msssTYI/AAAAAAAAAIg/bJGMmqBEi3A/s1600/Screen+shot+2010-07-12+at+7.27.48+PM.png"><img style="margin:0 10px 10px 0;cursor:pointer; cursor:hand;width: 400px; height: 171px;" src="http://4.bp.blogspot.com/_HWobMsJuRHc/TDu1msssTYI/AAAAAAAAAIg/bJGMmqBEi3A/s400/Screen+shot+2010-07-12+at+7.27.48+PM.png" border="0" alt=""id="BLOGGER_PHOTO_ID_5493183846946721154" /></a><br /><br />Well what the heck? It looks like it's all String data?<br /><br />JRuby's String implementation is an org.jruby.RubyString object, aggregating an org.jruby.util.ByteList object, aggregating a byte array, so the top three entries there in total are essentially all String memory. The best way to investigate where they're coming from is to do "List Objects" on RubyString, but instead of "with outgoing references" we'll use "with incoming references" to show where all those Strings are coming from.<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://4.bp.blogspot.com/_HWobMsJuRHc/TDu3PL9iEqI/AAAAAAAAAIw/AohfdQ-indA/s1600/Screen+shot+2010-07-12+at+7.44.44+PM.png"><img style="margin:0 10px 10px 0;cursor:pointer; cursor:hand;width: 400px; height: 321px;" src="http://4.bp.blogspot.com/_HWobMsJuRHc/TDu3PL9iEqI/AAAAAAAAAIw/AohfdQ-indA/s400/Screen+shot+2010-07-12+at+7.44.44+PM.png" border="0" alt=""id="BLOGGER_PHOTO_ID_5493185642045248162" /></a><br /><br />Finally we have a view that lets us hunt through all these strings and see where they're coming from. Poking at the first few shows they're stored in constant tables of the Gem module (that last RubyModule I haven't expanded in). That's probably not a big deal. But if we sort the the list of RubyString objects by their retained sizes, we get a different picture of the system.<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://4.bp.blogspot.com/_HWobMsJuRHc/TDu8gRTVaOI/AAAAAAAAAI4/k8kwxSTyr3g/s1600/Screen+shot+2010-07-12+at+8.07.09+PM.png"><img style="margin:0 10px 10px 0;cursor:pointer; cursor:hand;width: 400px; height: 272px;" src="http://4.bp.blogspot.com/_HWobMsJuRHc/TDu8gRTVaOI/AAAAAAAAAI4/k8kwxSTyr3g/s400/Screen+shot+2010-07-12+at+8.07.09+PM.png" border="0" alt=""id="BLOGGER_PHOTO_ID_5493191433094785250" /></a><br /><br />If we dig into the *largest* String objects, they appear to be referenced by Gem::Specification instance variables! So there's probably something worth investigating here.<br /><br />It's also worth noting that any Ruby application is going to have a lot of Strings in it, so this isn't all that unusual to see. But it's nice to have a tool that lets you investigate potential inefficiencies (even down to the raw bytes!), and it's nice to know that at least some of that retained data for the Gem module is "real" and not just references back into the class hierarchy.<br /><br />(And I'm not convinced all those Strings really *need* to be alive...but you're welcome to take it from here!)<br /><br /><span style="font-weight:bold;">Your Turn</span><br /><br />Eclipse MAT is probably one of the nicest of the free tools. In addition to object browsing, leak detection, GC root analysis, and object query language support, there's a ton of other features, both in the main distribution and available from third parties. If you're hunting for memory leaks, or just want to investigate the memory usage of your (J)Ruby application, MAT is a tool worth playing with (and as always, I hope you will blog and report your experiences!)