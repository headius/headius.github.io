---
layout: post
title: Improving Java Integration Performance
date: '2007-01-30T10:46:00.000-08:00'
author: headius
tags: 
modified_time: '2011-01-25T21:44:33.249-08:00'
blogger_id: tag:blogger.com,1999:blog-4704664917418794835.post-8822122190939455834
blogger_orig_url: http://blog.headius.com/2007/01/improving-java-integration-performance.html
---

I created JRUBY-501 to track performance improvements to Java  integration, since it's come to light recently that it may be one of our  biggest bottlenecks now. And I found a ripe, juicy fix already.<br /><br />For every call to a Java type, we call JavaUtilities.matching_method  with a list of potential methods and the given argument list.  matching_method compares the available methods and the types of the  arguments, choosing the best option and returning it to be called. This  is essentially our heuristic for choosing an overloaded method from many  options, given a set of arguments.<br /><br />Problem was, we didn't cache anything.<br /><br />Given a list of argument types and a list of methods, there's only ever  going to be one appropriate choice. Unfortunately our code was doing the  search for every single call, and you can imagine how much additional  overhead that added. Or perhaps you can't, and I'll show you.<br /><br />Here's the numbers before my tiny change:<br /><pre> 38.862000   0.000000  38.862000 ( 38.861000)<br /> 40.230000   0.000000  40.230000 ( 40.230000)</pre>This test basically just instantiates a StringBuffer and appends the  same character to it 100_000 times. It takes roughly 40 seconds to do  that with the old code.<br /><br />And here's with my changes:<br /><pre>  3.295000   0.000000   3.295000 (  3.294000)<br />  2.933000   0.000000   2.933000 (  2.933000)</pre>Yes, you're reading that right. It's an 13 times improvement.<br /><br />And the change was trivial: given the list of methods and argument  types, cache the correct method. So simple, so elegant, so effective.<br /><br />So does this affect regular Ruby code? You better believe it does!<br /><br />I had been intrigued by the fact that some of the first methods JITed  during rdoc generation were all JavaSupport methods. That told me  something in rdoc was using a class we provide through Java integration,  rather than natively or in pure Ruby. So I figured with this change, I'd  re-run the numbers.<br /><br />Before the change, a full rake install with rdoc took about 42s, or  about 31s with ObjectSpace disabled. And now, the "after" numbers:<br /><pre>with ObjectSpace:<br />real    0m29.765s<br />user    0m28.843s<br />sys     0m2.169s<br /><br />without ObjectSpace:<br />real    0m24.984s<br />user    0m23.559s<br />sys     0m1.757s</pre>This is by far the largest increase we've seen in rdoc performance in  several months. The fix should also drastically improve the performance  of libraries like ActiveRecord-JDBC, which is extremely  Java-integration-heavy.<br /><br />Another area that's been painful was installing Rails with all docs. It used to take over an hour, but now it's under *seven minutes*.<br /><br />I hope those of you who've seen or blogged about performance problems (especially with the aforementioned ActiveRecord-JDBC) will try re-running your tests. This improvement ought to have a very noticeable effect on benchmarks.<br /><br />Now the only concern I have with the caching is that it's a little  coarse; there may be better places to do the caching, or finer-grained  items to cache against. And we could probably pre-fill the cache with  some likely candidates. But an improvement like this outweighs those  concerns, so it's been committed...and there's bound to be similar  improvements as well.<br /><br />Boy oh boy is that low-hanging fruit looking ripe.