---
layout: post
title: 'JRuby Compiler: In Trunk and Ready to Play'
date: '2007-01-18T21:28:00.000-08:00'
author: headius
tags:
- ruby
- ruby 2.0
- ruby compiler
- yarv
- jruby
- java
modified_time: '2011-01-25T21:44:33.277-08:00'
blogger_id: tag:blogger.com,1999:blog-4704664917418794835.post-868304546880468253
blogger_orig_url: http://blog.headius.com/2007/01/jruby-compiler-in-trunk-and-ready-to.html
---

Times they are a-changing.<br /><br />I posted previously on JRuby's compiler work. There have been various iterations of the compiler, many purely prototype and never intended to be completed, and a few genuine attempts at evolving toward full Ruby support. However I believe in the recent weeks I've settled on a design that will carry us to the JRuby compiler endgame.<br /><br />For the past year, we've emphasized correctness over performance nine times out of ten. When we did focus on performance, it was solely on improving JRuby's interpreter speed, in an attempt to match Ruby's performance in this area and because we knew that JRuby could never entirely escape interpretation. Ruby's just too dynamic for that. So while compatibility with Ruby 1.8.x continued to improve by leaps and bounds, our performance was rather poor in comparison.<br /><br />This past fall, things started to change. Compatibility reached a point where we could finally be confident about our set of regression tests and our understanding of "how Ruby works" across all its weirdest features. As we understood better the design of the C implementation and the quirky intricacies of the language, we started to see a path to enlightenment. We started to realize how we could support Ruby as it exists today while simultaneously evolving JRuby into a more efficient and cleaner design. And so the performance numbers started to change.<br /><br />From 0.9.0 to 0.9.1, we had a clean doubling of performance across the board. Our favorite benchmark--RDoc generation--was easily twice as fast, and other simpler benchmarks like fib had similar improvements. 0.9.2 was more of a rushed release for JavaPolis, but we had a good 1/4 to 1/3 speedup even then, since the ongoing refactoring removed another large chunk of overhead from JRuby's core runtime.<br /><br />From 0.9.2 to current trunk, however, has been a different matter entirely.<br /><br />The first major change is that we've started to seriously alter the way JRuby does dynamic method dispatching. I did some research, read a few papers, and mocked up and benchmarked a few options. What we've settled on for the moment is a combination of STI for the core classes (STI provides a large table mapping methods and classes to actual code) and various forms of inline caching for non-core classes (basically, for pure Ruby classes; though this is yet to be implemented in trunk). STI provides an extremely fast path for dispatch on those hardest-hit methods, since it reduces calling most core methods to two array indexes and a switch, a vast improvement over the hash lookup and multiple layers of abstraction and framing we had before.<br /><br />We are continuing to expand our use of STI as it is applicable, and I will soon start exploring options for interpreted-mode inline caching (polymorphic, likely, though I need to run a few trials to get numbers balanced right). So fast dynamic dispatching is well on its way, and will improve performance across the board.<br /><br />Then there's the compiler work. You have no idea how much it's irritated me to hear people talk about JRuby the past year and say "yeah, but it doesn't compile to Java bytecode." This obviously amounts to pure FUD, but beyond that it totally ignores the complexity of the problem: not a single person on this earth has managed to compile Ruby to a general-purpose VM yet. So complaining about our missing compiler is a bit like complaining that we haven't moved mountains. Honestly people, what do you expect?<br /><br />Of course, there's the flip side of this statement: compiling Ruby is a hard problem, and I like hard problems. For me it's doubly hard, since I've never written a compiler before. But hell, before JRuby I'd never even worked on an interpreter or language implementation before, and that seems to have gone alright. So there it is...Mount Ruby, waiting to be climbed. And climb it I must!<br /><br />The current compiler design lives in two halves: the AST-walking half; and the code-generation half. I chose to split these two because it make several things easier. For starters, it allows me to abstract all the bytecode generation logic behind a simple interface, an interface that presents coarse-grained operations like invokeDynamic() and retrieveLocalVariable(). The ultimate implementation of those operations can then be modified at will. It also allows us to evolve the AST independently of the compiler backend, even to the point of swapping in a completely different parser and in-memory code representation (like <a href="http://ola-bini.blogspot.com/2007/01/executing-yarv-in-jruby.html">YARV bytecodes</a>) without harming the evolving code generator backend. So this split helps future-proof the compiler work.<br /><br />The current design also has another advantage: not all of Ruby has to compile for it to be useful. Currently, as the AST walker encounters nodes, if it finds a node it can't deal with it simply raises an exception. Compilation terminates, and the compiler's client can deal with the result as it will. This leads to a really powerful feature of this design: we can install the compiler now as a JIT and as it evolves more and more code will automatically get optimized. So once we're confident that a given node type is 100% compiling correctly, that node will now be eligible for JIT compilation. As an example, here's the output from a gem installation with the current compiler enabled as a JIT (with my logging in place, naturally):<br /><pre>compiled: TarHeader.empty?<br />compiled: Entry.initialize<br />compiled: Entry.full_name<br />compiled: Entry.bytes_read<br />compiled: Entry.close<br />compiled: Entry.invalidate<br />Successfully installed rake, version 0.7.1<br />Installing ri documentation for rake-0.7.1...<br />compiled: LeveledNotifier.notify?<br />compiled: LeveledNotifier.&lt;=&gt;<br />compiled: RubyLex.getc<br />compiled: null.debug?<br />compiled: BufferedReader.ungetc<br />compiled: Token.set_text<br />compiled: RubyLex.line_no<br />compiled: RubyLex.char_no<br />compiled: BufferedReader.column<br />compiled: RubyToken.set_token_position<br />compiled: Token.initialize<br />compiled: RubyLex.get_read<br />compiled: RubyLex.getc_of_rests<br />compiled: BufferedReader.getc_already_read<br />compiled: BufferedReader.peek<br />compiled: RubyParser.peek_tk<br />compiled: TokenStream.add_token<br />compiled: TokenStream.pop_token<br />compiled: CodeObject.initialize<br />compiled: RubyParser.remove_token_listener<br />compiled: Context.ongoing_visibility=<br />compiled: PreProcess.initialize<br />compiled: AttrSpan.[]<br />compiled: null.wrap<br />compiled: JavaProxy.to_java_object<br />compiled: Lines.next<br />compiled: Line.isBlank?<br />compiled: Fragment.add_text<br />compiled: Fragment.initialize<br />compiled: ToFlow.convert_string<br />compiled: LineCollection.add<br />compiled: Entry_.path<br />compiled: Entry_.directory?<br />compiled: Entry_.dereference?<br />compiled: AttrSpan.initialize<br />compiled: Entry_.prefix<br />compiled: Entry_.rel<br />compiled: Entry_.remove<br />compiled: Lines.rewind<br />compiled: AnyMethod.&lt;=&gt;<br />compiled: Description.serialize<br />compiled: AttributeManager.change_attribute<br />compiled: AttributeManager.attribute<br />compiled: ToFlow.annotate<br />compiled: NamedThing.initialize<br />compiled: ClassModule.full_name<br />compiled: Lines.initialize<br />compiled: Lines.empty?<br />compiled: LineCollection.normalize<br />compiled: ToFlow.end_accepting<br />compiled: Verbatim.add_text<br />compiled: FalseClass.to_s<br />compiled: TopLevel.full_name<br />compiled: Attr.&lt;=&gt;<br />Installing RDoc documentation for rake-0.7.1...<br />compiled: Context.add_attribute<br />compiled: Context.add_require<br />compiled: Context.add_class<br />compiled: AbstructNotifier.notify?<br />compiled: Context.add_module<br />compiled: LineReader.read<br />compiled: null.instance<br />compiled: HtmlMethod.path<br />compiled: HtmlMethod.aref<br />compiled: ContextUser.initialize<br />compiled: HtmlClass.name<br />compiled: TokenStream.token_stream<br />compiled: LineReader.initialize<br />compiled: TemplatePage.write_html_on<br />compiled: Context.push<br />compiled: Context.pop<br />compiled: HtmlMethod.name<br />compiled: Context.find_local_symbol<br />compiled: SimpleMarkup.add_special<br />compiled: TopLevel.find_module_named<br />compiled: Context.find_enclosing_module_named<br />compiled: HtmlMethod.&lt;=&gt;<br />compiled: ToHtml.annotate<br />compiled: HtmlMethod.visibility<br />compiled: HtmlMethod.section<br />compiled: HtmlMethod.document_self<br />compiled: LineReader.dup<br />compiled: Lines.unget<br />compiled: ToHtml.accept_paragraph<br />compiled: ContextUser.document_self<br />compiled: ToHtml.accept_heading<br />compiled: Heading.head_level<br />compiled: ToHtml.accept_list_start<br />compiled: ToHtml.accept_list_end<br />compiled: ToHtml.accept_verbatim<br />compiled: SimpleMarkup.initialize<br />compiled: AttributeManager.initialize<br />compiled: ToHtml.initialize<br />compiled: ToHtml.end_accepting<br />compiled: HtmlMethod.singleton<br />compiled: Context.modules<br />compiled: Context.classes<br />compiled: ContextUser.build_include_list<br />compiled: HtmlMethod.description<br />compiled: HtmlMethod.parent_name<br />compiled: HtmlMethod.aliases<br />compiled: HtmlClass.parent_name<br />compiled: ContextUser.as_href<br />compiled: ContextUser.url<br />compiled: ContextUser.aref_to<br />compiled: HtmlFile.&lt;=&gt;<br />compiled: HtmlClass.&lt;=&gt;</pre>You can see from the output that not only are RubyGems methods getting compiled, but so are stdlib methods and our own Java integration methods. And this is with the current compiler, which doesn't support compiling class defs, blocks, case statements, ... Hopefully you get the picture; this bit-by-bit implementation of the compiler allows us to slowly grow our ability to optimize Ruby into Java bytecodes.<br /><br />So then, how well does it perform? It performs just dandy, when we're able to compile. Witness the following results for a simple recursive fib algorithm running under Ruby 1.8.5 and JRuby trunk with the JIT enabled.<br /><br /><pre>$ ruby test/bench/bench_fib_recursive.rb<br />12.760000   1.400000  14.160000 ( 14.718925)<br />12.660000   1.490000  14.150000 ( 14.648681)<br />$ JAVA_OPTS=-Djruby.jit.enabled=true jruby test/bench/bench_fib_recursive.rb<br />compiled: Object.fib_ruby<br />8.780000   0.000000   8.780000 (  8.780000)<br />7.761000   0.000000   7.761000 (  7.761000)</pre>Yes, that's nearly double the performance of the C implementation of Ruby. And this is absolutely real.<br /><br />Now JITing is great, and it's obviously carried Java a long ways. The HotSpot JIT is an unbelievable piece of work, and any app that runs a long time is guaranteed to perform better and better as deeper optimizations start to take hold. But We're talking about Ruby here, which starts up at C-program speeds, and runs as fast as it does immediately. So then JRuby needs a way to compete for immediate execution performance, and the most straightforward way to do that is with an ahead-of-time compiler. That compiler is now also available in JRuby trunk.<br /><br />The name of the command is "jrubyc", and it does just what you'd expect, it outputs a Java class file for your Ruby code. However the mapping from Ruby code to a class file is not as straightforward as you'd expect: a Ruby script may contain many classes or no classes at all, and those classes may be opened and re-opened by the same script or other scripts at runtime. So there's no way to map directly from a Ruby class to a Java class given the strict limitations of Java's class model. But there is a much smaller unit of code that does not change over time, aside from being mercilessly juggled around: methods.<br /><br />Ruby, in the end, is a creative and sometimes complicated jumble of method "objects", floating from class to class, from module to module, from namespace to namespace. Methods can be renamed, redefined, added and removed, but never can they be directly modified. And so here is where we have our immutable item to compile.<br /><br />JRuby's compiler takes a given Ruby script and generates the following Java methods out of it: One Java method for the top-level, straight-through execution of the script, including class bodies and "def"s and the like (called "__file__" in the eventual Java class...thanks Ola for the idea), and a Java method for every Ruby method body and closure contained therein, named in such a way as to avoid conflicts. So for the following piece of code:<br /><pre>require 'foo'<br /><br />def bar<br />baz { puts "hello" }<br />end<br /><br />def baz<br />yield<br />end<br /></pre>There would be four Java methods generated: one for the toplevel execution of the script, two for the bar and baz methods, and one for the closure contained within bar. The resulting class file would store these as static methods, so they are accessible from any class or object as necessary, and the toplevel run-through would bind the two Ruby methods to their appropriate names in Ruby-space.<br /><br />Quite simple, really!<br /><br />So then an example of the precious, precious JRuby compiler:<br /><pre>$ cat fib_recursive.rb<br />def fib_ruby(n)<br />if n &lt; 2<br />n<br />else<br />fib_ruby(n - 2) + fib_ruby(n - 1)<br />end<br />end<br /><br />puts fib_ruby(34)<br />$ jrubyc fib_recursive.rb<br />$ ls fib_recursive.*<br />fib_recursive.class  fib_recursive.rb<br />$ time java -cp lib/jruby.jar:lib/asm-2.2.2.jar:. fib_recursive<br />5702887<br /><br />real    0m8.126s<br />user    0m7.632s<br />sys     0m0.208s<br />$ time ruby fib_recursive.rb<br />5702887<br /><br />real    0m14.649s<br />user    0m12.945s<br />sys     0m1.480s</pre>Again, about twice as fast as Ruby 1.8.5 for this particular benchmark.<br /><br />Now I don't want you going off and saying JRuby has a perfect compiler that will double the performance of your Rails apps. That's not true yet. The current compiler covers only about 30% of the possible code constructs in Ruby, and the remaining 60% (<span style="font-style: italic;">Update:</span> 70%...that's what I get for late-night blogging) contains some of the biggest challenges like closures and class definitions. It's sure to be buggy right now, and the JIT isn't even enabled by default, plus it has my nasty logging message burned into it, to discourage any production use.<br /><br />But it is very real. JRuby has a partial but growing compiler for Ruby to Java bytecode now.<br /><br />And oh my, look at the time. Tonight I have to finish my visa application for a trip to India, nail down schedules and descriptions for several upcoming talks, and prepare some slides and notes for presentations in the coming weeks. You will see more about the Java compilation and our developing <a href="http://ola-bini.blogspot.com/2007/01/executing-yarv-in-jruby.html">YARV/Ruby 2.0 bytecode support</a> over the next couple months...and you can expect JavaOne to be an interesting time for Ruby on the JVM this year ;)