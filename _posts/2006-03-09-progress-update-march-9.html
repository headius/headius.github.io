---
layout: post
title: Progress Update March 9
date: '2006-03-09T07:23:00.000-08:00'
author: headius
tags: 
modified_time: '2011-01-25T21:44:34.896-08:00'
blogger_id: tag:blogger.com,1999:blog-4704664917418794835.post-2612596194509005680
blogger_orig_url: http://blog.headius.com/2006/03/progress-update-march-9.html
---

It's been a busy few days. We've made more good progress, so I figured an update was due.<br /><br /><span style="font-weight: bold;">Last Class</span><br /><br />Tom discovered over the weekend that we had a problem setting the "last class" in the interpreter. This interfered with "super" calls working correctly.<br /><br />The "last class" is used to point at the appropriate class hierarchy for the currently-executing code. We were setting "last class" to the actual class or module the current object was an instance of. This is correct for classes, but it was completely wrong for modules. In Ruby (both C and J), modules are internally inserted into the inheritance chain using module "wrappers". These wrappers become an implicit superclass of the class doing the include, and the wrapper's superclass points at the class's original superclass. So in the following example...<br /><br /><span style="font-family:courier new;">module X; end<br />class Y; end<br />class Z &lt Y; include X; end<br /></span><br /><br />..the explicit class hierarchy shows Z extending Y, while internally Z's superclass is a wrapper for X, whose superclass is then Y.<br /><br />Having "last class" set appropriately in the interpreter is important because super calls must always be able to traverse the appropriate hierarchy. If, for example, you created a module-based "initialize" method (which some apps do to mix-in initialization behavior), and that initialize method called super, it must go to the appropriate superclass's initialize. Since modules do not have an initialize (and are uninstantiable), our original "last class" pointer at the module itself failed miserably. The initialize method was called correctly on the module, but super pointed at nothing.<br /><br />Once Tom had figured out how we ought to fix this, I whipped up a patch. We modified the method-calling pipeline to send the appropriate "last class" through to execution. This allows module methods to now run within the context of the includer's hierarchy, rather than in their own hierarchies. With that fixed, super calls are now working correctly.<br /><br /><span style="font-weight: bold;">Array#unshift</span><br /><br />Array#unshift now accepts an empty arg list. This is perhaps a Ruby 1.8.4 change. We had been forcing it to be at least one argument, as is documented in pickaxe. I noticed this problem while re-testing IRB with the "last class" fixes.<br /><br /><span style="font-weight: bold;">eval + Binding fixes</span><br /><br />Binding is a fairly recent addition to JRuby. We had not ever supported binding up until a few weeks ago, which killed apps like IRB and Rails in the cradle. Adding it opened up a world of opportunity.<br /><br />However, yesterday I discovered that code eval'ed with a Binding was not getting "self" correctly. Throughout the interpreter, there's one universal constant: "self" points to the current object. In a pure OO language like Ruby, all code is executed in the context of an object. Code at the top level executes within the context of the top-level Object instance, instance methods execute within the object they are called against, and so on.<br /><br />When calling eval, you can choose to specify a binding or not. eval("code") evaluates the code in the current object (i.e. the current "self"), as well as within the current call frame, scope, class, etc. eval("code", some_binding) evaluates the code within another context entirely, with a different "self", frame, and friends.<br /><br />Our eval, though properly setting up the bound context's frame and friends, was not correctly setting self. It was always making self the current object. I fixed it to set self to the correct object when called with a binding, and it appears to be working correctly.<br /><br /><span style="font-weight: bold;">IRB</span><br /><br />With my update to Ruby 1.8.4 code and the "last class" fixes, IRB suddenly stopped working. Bummer. To make matters worse it started failing late last night, and I couldn't find all the issues.<br /><br />However, on the bus ride to work today, I fixed both the eval and Array problems that were preventing IRB from working. Starting up IRB again I received a lovely surprise:<br /><br /><span style="font-family:courier new;">C:\JRubyWork\jruby&gt;jirb<br />irb(main):001:0&gt;</span><br /><br />It is the good old IRB prompt, rather than the hideous IRB::Workspace::Nonsense!<br /><br />The "self" issue prevented IRB from running at all with the "last class" fixes in place, and was the cause of two other issues with IRB: the need for --single-irb mode, and the ugly prompt.<br /><br />With the eval issue fixed, IRB now runs without the need for --single-irb mode, and I have updated our "jirb" scripts to reflect this. It also runs with the appropriate prompt. This will make me much happier and our future IRB demos much prettier.<br /><br /><span style="font-weight: bold;">Rails</span><br /><br />My goodness Rails is a gigantic thing.<br /><br />We are continuing to make good progress on Rails. With all the above fixes, the generate script now runs through to initialization of the Routing subsystem. There it fails with an argument error that could be an interpreter or API issue.<br /><br />I have also ventured a bit beyond this--by commenting routing out--and ran into a Ruby syntax we do not yet support:<br /><br /><span style="font-family:courier new;">x = {}<br />[1].each {|x[:foo]|}<br /></span><br />Ruby at some point (probably in 1.8) added the ability to specify an array or hash index as the target for a block argument. While I can see the usefulness of this shortcut (rather than {|v| x[:foo] = v}) I must say this syntactic sugar is a bit sweet for my tastes. At any rate, it's there and we need to support it.<br /><br />Rails so far only uses this syntax when printing out usage for the generate script. I modified that script to use the longhand version, and it was able to continue.<br /><br />With routing commented out and the block arg syntax modified, the generate script ran to completion. We're getting closer!<br /><br />Executing the generate script with a specific generator caused some other issues, whereby JRuby sees a yield without seeing a block to yield to. It's not functional yet, but it's moving right along.<br /><br />Tom is also working on the other end of things, running Rails in "CGI mode" to test execution of an actual Rails request. At this point he's stuck on the same argument issue that's preventing routing from starting up, so that's what we'll work on next.<br /><br /><span style="font-weight: bold;">JavaOne 2006</span><br /><br />As most of you will know, we will be presenting JRuby at JavaOne this year. We have almost finished our slides and will be sending them to Sun tomorrow. We obviously can't show you the slides themselves (since we want you to come see them in person) but we do hope to do most of the following five demonstrations:<br /><ul><li>Interactive JRuby with IRB</li><li>JDBC in Ruby</li><li>Swing in Ruby</li><li>Spring in Ruby</li><li>Rails</li></ul>Obviously the Rails demo will only happen if there's something to show...but we're banking on having something working by then. We may have to drop one of the others for time, but I hope to touch on them all. We hope to see you all at JavaOne!</span>