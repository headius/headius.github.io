---
layout: post
title: Nibbling Away at Performance
date: '2006-08-11T10:18:00.000-07:00'
author: headius
tags: 
modified_time: '2011-01-25T21:44:34.269-08:00'
blogger_id: tag:blogger.com,1999:blog-4704664917418794835.post-8005060174026860106
blogger_orig_url: http://blog.headius.com/2006/08/nibbling-away-at-performance.html
---

JRuby's performance has never been stellar. Even before the current performance-hindering refactoring and "correctification" work began, it was almost an order of magnitude slower than MRI ("Matz's Ruby Interpreter"). When I started working on my parts of the JRuby internal redesign, I knew thing were going to get worse before they got better...but I think they're finally starting to get better.<br /><br />I ran some quick numbers comparing performance of JRuby 0.9.0 versus current trunk:<br /><br />Under 090, gem install rake-0.7.1.gem:<br />real    1m39.088s<br />user    1m37.666s<br />sys     0m1.128s<br /><br />Under trunk:<br />real    1m16.388s<br />user    1m15.233s<br />sys     0m0.924s<br /><br />That equates to about a 23% improvement in speed. Considering that we've only been nibbling at performance and that our large-scale performance-related refactoring has just begun, things are looking a lot better than they were six months ago.<br /><br />The current goal is to get interpreted-mode JRuby as close as possible to MRI performance before we commit to a bytecode compiler. Because the eventual compiler will have to appropriately hook into JRuby's runtime, this only makes sense: if we go full-bore on a compiler now we may see great improvement in performance, but we'll have a much harder time evolving the runtime. By making the interpreter runtime as well-designed and as fast as possible now, we run less of a risk that compilation later on will tie us to a poor runtime design. I believe too many language projects fall into the trap of immediately diving into compilation without first considering how a language should best be represented on the target machine. When we do the hard work of improving the interpreter first, we learn the nuances of the language and gain a better understanding of how that compiler should eventually look. It may even be the case that we find a more direct mapping from the language to the platform that allows us to minimize or eliminate the runtime entirely for compiled code. We'd never reach that conclusion if we prematurely optimized by banking on a compiler too early.<br /><br />At any rate, things are looking good for JRuby performance, both for small-scale optimizations and large-scale refactorings. The compiler will just make good...better.