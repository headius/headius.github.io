---
layout: post
title: FFI for Ruby Now Available
date: '2008-10-31T14:21:00.000-07:00'
author: headius
tags: 
modified_time: '2011-01-25T21:44:31.249-08:00'
blogger_id: tag:blogger.com,1999:blog-4704664917418794835.post-1804825522200804514
blogger_orig_url: http://blog.headius.com/2008/10/ffi-for-ruby-now-available.html
---

One of the largest problems plaguing Ruby implementations (and plaguing some other language implementations, so I hear from my Pythonista friends) is the ever-painful story of "extensions". In general, these take the form of a dynamic library, usually written in C, that plugs into and calls Ruby's native API as exposed through ruby.h and libruby. Ignoring for the moment the fact that this API exposes way more of Ruby's internals than it should, extensions present a very difficult problem for other implementations:<br /><br />Do we support them or not?<br /><br />In many cases, this question is answered for us; most extensions require access to object internals we can't expose, or can't expose without extremely expensive copying back and forth. But there's also a silver lining: the vast majority of C-based extensions exist solely to wrap another library.<br /><br />Isn't it obvious what's needed here?<br /><br />This problem has been tackled by a number of libraries on a number of platforms. On the JVM, there's Java Native Access (JNA). On Python, there's ctypes. And even on Ruby, there's the "dl" stdlib, wrapping libdl for programmatic access to dynamic libraries. But dl is not widely used, because of real or perceived bugs and a rather arcane API. Something better is needed.<br /><br />Enter FFI.<br /><br />FFI stands for Foreign Function Interface. FFI has been implemented in various libraries; one of them, libffi, actually serves as the core of JNA, allowing Java code to load and call arbitrary C libraries. libffi allows code to load a library by name, retrieve a pointer to a function within that library, and invoke it, all without static bindings, header files, or any compile phase.<br /><br />In order to address a need early in Rubinius's dev cycle, Evan Phoenix came up with an FFI library for Rubinius, wrapping the functionality of libffi in a friendly Ruby DSL-like API.<br /><br /><span style="font-style:italic;">A simple FFI script calling the C "getpid" function:</span><br /><pre>require 'ffi'<br /><br />module GetPid<br />  extend FFI::Library<br /><br />  attach_function :getpid, [], :uint<br />end<br /><br />puts GetPid.getpid</pre>Because JRuby already ships with JNA, and because FFI could fulfill the C-extension needs of almost all Ruby users, we endeavored to create a compatible implementation. And by we I mean Wayne Meissner.<br /><br />Wayne is one of the primary maintainers of JNA, and has recently spent time on a new higher-performance version of it called JFFI. Wayne also became a JRuby committer this spring, and perhaps his most impressive contribution to date is a full FFI library for JRuby, based on JNA (eventually JFFI, once we migrate fully) and implementing the full set of what we and Evan agreed would be "FFI API 1.0". We shipped the completed FFI support in JRuby 1.1.4.<br /><br /><span style="font-style:italic;">The "Passwd" and "Group" structures for functions like 'getpwuid':</span><br /><pre>module Etc<br />  class Passwd &lt; FFI::Struct<br />    layout :pw_name, :string, 0,<br />           :pw_passwd, :string, 4,<br />           :pw_uid, :uint, 8,<br />           :pw_gid, :uint, 12,<br />           :pw_dir, :string, 20,<br />           :pw_shell, :string, 24<br />  end<br />  class Group &lt; FFI::Struct<br />    layout :gr_name, :string, 0,<br />           :gr_gid, :uint, 8<br />  end<br />end</pre>In JRuby 1.1.5, we've taken another step forward with the API, adding support for callbacks. How would you represent a callback you pass into a C function from Ruby? How else! As a block!<br /><br /><span style="font-style:italic;">Binding and calling "qsort" with an array of integers:</span><br /><pre>require 'ffi'<br /><br />module LibC<br />  extend FFI::Library<br />  callback :qsort_cmp, [ :pointer, :pointer ], :int<br />  attach_function :qsort, [ :pointer, :int, :int, :qsort_cmp ], :int<br />end<br /><br />p = MemoryPointer.new(:int, 2)<br />p.put_array_of_int32(0, [ 2, 1 ])<br />puts "Before qsort #{p.get_array_of_int32(0, 2).join(', ')}"<br />LibC.qsort(p, 2, 4) do |p1, p2|<br />  i1 = p1.get_int32(0)<br />  i2 = p2.get_int32(0)<br />  i1 &lt; i2 ? -1 : i1 &gt; i2 ? 1 : 0<br />end<br />puts "After qsort #{p.get_array_of_int32(0, 2).join(', ')}"</pre>But what good is having such a library if it doesn't run everywhere? Up until recently, only Rubinius and JRuby supported FFI, which made our case for cross-implementation use pretty weak. Even though we were getting good use out of FFI, there was no motivation for anyone to use it in general, since the standard Ruby implementation had no support.<br /><br />That is, until Wayne pulled another rabbit out of his hat and implemented FFI for C Ruby as well. The JRuby team is proud to announce a wholly non-JRuby library: FFI is now available on Ruby 1.9 and Ruby 1.8.6/7, in addition to JRuby 1.1.4+ and Rubinius (though Rubinius does not yet support callbacks).<br /><br /><span style="font-style:italic;">Session showing installation and use of FFI in C Ruby:</span><br /><pre>$ sudo gem install ffi<br />Password:<br />Building native extensions.  This could take a while...<br />Successfully installed ffi-0.1.1<br />1 gem installed<br />Installing ri documentation for ffi-0.1.1...<br />Installing RDoc documentation for ffi-0.1.1...<br />[headius @ cnutter:~]<br />$ irb<br />&gt;&gt; require 'ffi'<br />=&gt; true<br />&gt;&gt; module RubyFFI<br />&gt;&gt; extend FFI::Library<br />&gt;&gt; attach_function :getuid, [], :uint<br />&gt;&gt; end<br />=&gt; #&lt;FFI::Invoker:0x1fe8c&gt;<br />&gt;&gt; puts RubyFFI.getuid<br />501<br />=&gt; nil<br />&gt;&gt; </pre>Our hope with JRuby's support of FFI and our release of FFI for C Ruby is that we may finally escape the hell of C extensions. Next time you need to call out to a C library, don't write a wrapper shim in C! Write it using FFI, and it will work across implementations without recompile.<br /><br />Here's some links to docs on FFI. As with most open-source projects, documentation is a little light right now, but hopefully that will change.<br /><br /><a href="http://wiki.jruby.org/wiki/Calling_C_from_JRuby">Calling C from JRuby</a><br /><a href="http://blog.segment7.net/articles/2008/01/15/rubinius-foreign-function-interface">Rubinius's Foreign Function Interface</a><br /><a href="http://pluskid.lifegoo.com/?p=370">On the Rubinius FFI</a><br /><br />A key feature that's not well documented is the use of FFI's templating system to generate bindings based on the current platform's header files. Here's a sample from the "Etc" module above.<br /><br /><span style="font-style:italic;">Etc module template, showing how to pull in header files and inspect a struct definition:</span><br /><pre>module Etc<br />  class Passwd &lt; FFI::Struct<br />    @@@<br />    struct do |s|<br />      s.include "sys/types.h"<br />      s.include "pwd.h"<br /><br />      s.name "struct passwd"<br />      s.field :pw_name, :string<br />      s.field :pw_passwd, :string<br />      s.field :pw_uid, :uint<br />      s.field :pw_gid, :uint<br />      s.field :pw_dir, :string<br />      s.field :pw_shell, :string<br />    end<br />    @@@<br />  end<br />  class Group &lt; FFI::Struct<br />    @@@<br />    struct do |s|<br />      s.include "sys/types.h"<br />      s.include "grp.h"<br /><br />      s.name "struct group"<br />      s.field :gr_name, :string<br />      s.field :gr_gid, :uint<br />    end<br />    @@@<br />  end<br />end</pre>As more docs come to my attention, I'll update this post and add links to the JRuby wiki page. For those of you interested in the Ruby FFI project itself, check out the <a href="http://kenai.com/projects/ruby-ffi">Ruby FFI project on Kenai</a>. And feel free to hunt down any of the JRuby team, including Wayne Meissner, on the JRuby mailing lists or in #jruby on FreeNode.<br /><br /><span style="font-weight:bold;"><span style="font-style:italic;">Update:</span></span> Wayne has posted a follow-up with more details here: <a href="http://wmeissner.blogspot.com/2008/11/more-on-ruby-ffi.html">More on Ruby FFI</a>