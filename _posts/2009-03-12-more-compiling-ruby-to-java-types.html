---
layout: post
title: More Compiling Ruby to Java Types
date: '2009-03-12T21:20:00.000-07:00'
author: headius
tags: 
modified_time: '2011-01-25T21:44:30.992-08:00'
blogger_id: tag:blogger.com,1999:blog-4704664917418794835.post-3928925875015732361
blogger_orig_url: http://blog.headius.com/2009/03/more-compiling-ruby-to-java-types.html
---

I did another pass on <a href="{{ site.baseurl }}{% post_url 2009-03-12-more-compiling-ruby-to-java-types %}">compiler2</a>, and managed to wire in signature support. So let's look at a couple examples:<br /><pre>class MyRubyClass<br /> def helloWorld<br />   puts "Hello from Ruby"<br /> end<br /> def goodbyeWorld(a)<br />   puts a<br /> end<br /><br /> signature :helloWorld, [] =&gt; Java::void<br /> signature :goodbyeWorld, [java.lang.String] =&gt; Java::void<br />end</pre><br />In this case we have our friend MyRubyClass once again, with helloWorld and goodbyeWorld methods. You'll recall from <a href="{{ site.baseurl }}{% post_url 2009-03-12-more-compiling-ruby-to-java-types %}">my previous post</a> that these two methods originally compiled as returning IRubyObject, and goodbyeWorld compiled as receiving a single IRubyObject parameter.<br /><br />But with signature support, things are so much cooler! The two "signature" lines at the bottom of the class (syntax and structure are totally up for debate) associated signatures with the two methods. helloWorld receives no parameters and has a void return type. goodbyeWorld receives a single String parameter and has a void return type.<br /><br />The compiler takes this new information, and produces a more normal-looking set of Java signatures:<br /><pre>Compiled from "MyObject.java.rb"<br />public class MyObject extends org.jruby.RubyObject{<br />   static {};<br />   public MyObject();<br />   public void helloWorld();<br />   public void goodbyeWorld(java.lang.String);<br />}</pre><br />Huzzah! There's almost nothing here to give away that we're actually dealing with Ruby code under the covers. And the code that consumes this is just as simple:<br /><pre>public class MyObjectTest {<br /> public static void main(String[] args) {<br />   MyObject obj = new MyObject();<br />   obj.helloWorld();<br />   obj.goodbyeWorld("hello");<br /> }<br />}</pre><br />And that's literally all there is to it. Here's a more advanced example:<br /><pre>class MyRubyClass<br /> %w[boolean byte short char int long float double].each do |type|<br />   java_type = Java.send type<br />   eval "def #{type}Method(a); a; end"<br />   signature "#{type}Method", [java_type] => java_type<br /> end<br />end</pre><br />This time we're actually *generating* the methods, looping over a list of Java primitives and eval'ing a method for each. So this is *runtime* generation of methods, like any good Rubyist loves to do. And of course, this is absolutely no problem for compiler2:<br /><pre>Compiled from "MyObject2.java.rb"<br />public class MyObject2 extends org.jruby.RubyObject{<br />   static {};<br />   public MyObject2();<br />   public double doubleMethod(double);<br />   public int intMethod(int);<br />   public char charMethod(char);<br />   public short shortMethod(short);<br />   public boolean booleanMethod(boolean);<br />   public float floatMethod(float);<br />   public long longMethod(long);<br />   public byte byteMethod(byte);<br />}</pre><br />All the methods are there, just as you'd expect them! Fantastic!!! (Though the ordering is a little peculiar; I think that's because we don't have an ordered method table in our class impl. Does it matter?)<br /><br />Even better, the above methods are doing the same type coercion on the way in and out that we do for any other Java-based method calling. So your integral numerics are presented to Ruby as Fixnums, floating-point numerics are Floats, and booleans come through as Ruby true or false.<br /><br />There's certainly more work to be done:<br /><ul><li>There's no support for overloads at the moment, but I'll likely provide a method aliasing facility so you can define multiple Ruby methods and then say which one maps to which overload. And of course, you'll be able to define multiple overloads that go to the same method body if you wish.</li><li>I also have not wired in varargs, but it will be an easy match to Ruby's restargs. And optional arguments could automatically generate different-arity Java signatures.</li><li>Annotations will also be trivial to add; it's just a matter of attaching appropriate metadata and having compiler2 emit them. So you'll be able to use JavaEE 5, JUnit4, and any other frameworks that depend on having annotations present.</li></ul>Of course this is all checked into JRuby trunk, so feel free to give it a try. Stop by JRuby mailing lists or IRC if you have questions. And it's all still written in Ruby; signature support bloated the compiler up to a whopping 178 lines of code, most of that for dealing with the JVM opcodes for primitive types.<div><br /></div><div>This is just the beginning!</div>