---
layout: post
title: Java 6 Port for OS X (Tiger and Leopard)
date: '2007-11-27T00:30:00.000-08:00'
author: headius
tags: 
modified_time: '2011-01-25T21:44:32.198-08:00'
blogger_id: tag:blogger.com,1999:blog-4704664917418794835.post-772979959941979180
blogger_orig_url: http://blog.headius.com/2007/11/java-6-port-for-os-x-tiger-and-leopard.html
---

I just stumbled across this little gem today:<br /><br /><a href="http://landonf.bikemonkey.org/code/macosx/">Landon Fuller's JDK 6 Port for OS X</a><br /><br />Who Landon Fuller is I don't know. But I find it incredibly impressive that he's managed to get the base JDK 6 ported to OS X and working. Talk about showing the value of an open-source JDK...Landon Fuller FTW. Apple, are you hiring? Perhaps this guy can kick the Apple JDK process in the ass.<br /><br />So naturally when I'm confronted with a final JDK 6 release for OS X one thing immediately springs to mind: performance.<br /><br />We'd always suspected that the early preview version of JDK 6 on OS X was not showing us the true awesome performance we could expect from a final version.<br /><br />We were right.<br /><br />So I'll give you two sets of numbers, one that's specious and unreliable and the other that's a more real-world test.<br /><br /><span style="font-weight: bold;">fib numbers</span><br /><br />Yes, good old fib. A constant in benchmarking. It shows practically nothing, and yet people use it to demonstrate perf. And in the case of Ruby 1.9, they've specifically optimized for integer-math-heavy benchmarks like this.<br /><br />Ruby 1.9:<br /><pre>  0.400000   0.000000   0.400000 (  0.413737)<br /> 0.420000   0.010000   0.430000 (  0.421622)<br /> 0.400000   0.000000   0.400000 (  0.411591)<br /> 0.410000   0.000000   0.410000 (  0.411593)<br /> 0.400000   0.000000   0.400000 (  0.410080)<br /> 0.410000   0.000000   0.410000 (  0.408836)<br /> 0.400000   0.000000   0.400000 (  0.408572)<br /> 0.410000   0.000000   0.410000 (  0.408114)<br /> 0.400000   0.000000   0.400000 (  0.410374)<br /> 0.400000   0.000000   0.400000 (  0.413096)</pre><br />Very nice numbers, especially considering Ruby 1.8 benchmarks at about 1.7s on my system. Ruby 1.9 contains several optimizations for integer math, including the use of "tagged integers" for Fixnum values (saving object costs) and fast math opcodes in the 1.9 bytecode specification (avoiding method dispatch). JRuby does neither of these, representing Fixnums as a normal Java object containing a wrapped Long and dispatching as normal for all numeric operations.<br /><br />JRuby trunk:<br /><pre>  0.783000   0.000000   0.783000 (  0.783000)<br /> 0.510000   0.000000   0.510000 (  0.510000)<br /> 0.510000   0.000000   0.510000 (  0.510000)<br /> 0.506000   0.000000   0.506000 (  0.506000)<br /> 0.505000   0.000000   0.505000 (  0.504000)<br /> 0.507000   0.000000   0.507000 (  0.507000)<br /> 0.510000   0.000000   0.510000 (  0.510000)<br /> 0.507000   0.000000   0.507000 (  0.507000)<br /> 0.508000   0.000000   0.508000 (  0.508000)<br /> 0.510000   0.000000   0.510000 (  0.510000)</pre><br />This is improved from numbers in the 0.68s range under the Apple JDK 6 preview. Pretty damn hot, if you ask me. I love being able to sit back and do nothing while performance numbers improve. It's a nice change from 16 hour days.<br /><br />Anyway, back to performance. JRuby also supports an experimental frameless execution mode that omits allocating and initializing per-call frame information. In Ruby, frames are used for such things as holding the current method visibility, the current "self", the arguments and block passed to a method, and so on. But in many cases, it's safe to omit it entirely. I haven't got it running 100% safe in JRuby yet, and probably won't before 1.1 final comes out...but it's on the horizon. So then...numbers.<br /><br />JRuby trunk, frameless execution:<br /><pre>  0.627000   0.000000   0.627000 (  0.627000)<br /> 0.409000   0.000000   0.409000 (  0.409000)<br /> 0.401000   0.000000   0.401000 (  0.401000)<br /> 0.402000   0.000000   0.402000 (  0.402000)<br /> 0.403000   0.000000   0.403000 (  0.403000)<br /> 0.403000   0.000000   0.403000 (  0.403000)<br /> 0.404000   0.000000   0.404000 (  0.405000)<br /> 0.401000   0.000000   0.401000 (  0.401000)<br /> 0.403000   0.000000   0.403000 (  0.403000)<br /> 0.405000   0.000000   0.405000 (  0.405000)</pre><br />Hello hello? What do we have here? JRuby actually executing fib faster than an optimized Ruby 1.9? Can it truly be?<br /><br />Pardon my snarkiness, but we never thought we'd be able to match Ruby 1.9's integer math performance without seriously stripping down Fixnum and introducing fast math operations into the compiler. I guess we were wrong.<br /><br /><span style="font-weight: bold;">M. Ed Borasky's MatrixBenchmark</span><br /><br />I like Borasky's matrix benchmark because it's a non-trivial piece of code, and pulls in a Ruby standard library (matrix.rb) as well. It basically inverts a matrix of a particular size and multiplies the original by the inverse. I show here numbers for a 64x64 matrix, since it's long enough to show the true benefit of JRuby but short enough I don't get bored waiting.<br /><br />Ruby 1.9:<br /><pre>Hilbert matrix of dimension 64 times its inverse = identity? true<br />21.630000   0.110000  21.740000 ( 21.879126)</pre>JRuby trunk:<br /><pre>Hilbert matrix of dimension 64 times its inverse = identity? true<br />14.780000   0.000000  14.780000 ( 14.780000)</pre><br />This is down from 16-17s under the Apple JDK 6 preview and a clean 25% faster than Ruby 1.9.<br /><br />So what have we learned today?<br /><ul><li>Sun's JDK 6 provides frigging awesome performance<br /></li><li>Apple users are crippled without a JDK 6 port. Apple, I hope you're paying attention.<br /></li><li>Landon Fuller is my hero of the week. I know Landon will just point at the excellent work to port JDK 6 to FreeBSD and OpenBSD...but give yourself some credit, you did what none of the other Leopard whiners did.</li><li>JRuby rocks</li></ul>Note: You have to be a <a href="http://java.net/jrl.csp">Java Research License</a> licensee to legally download the binary or source versions of Landon's port. That or complain to Apple about some dude making a working port before they did. Landon mentions on his blog that he plans to contribute this work to OpenJDK soon...which would quickly result in a buildable GPLed JDK for OS X. Awesome.