---
layout: post
title: Using Rubinius's Kernel in JRuby
date: '2008-10-29T01:25:00.000-07:00'
author: headius
tags: 
modified_time: '2011-01-25T21:44:31.263-08:00'
blogger_id: tag:blogger.com,1999:blog-4704664917418794835.post-3260904816954248975
blogger_orig_url: http://blog.headius.com/2008/10/using-rubinius-kernel-in-jruby.html
---

After a long day fixing bugs, ya gotta hack on something frivolous once in a while.<br /><br />I've started to play with a proof-of-concept branch that uses Rubinius's kernel (pure Ruby core class implementations) in replacement for our own (pure Java). Initially I've been playing with Hash, which is one of the few Rubinius core classes that does not have any "primitives" (native methods implemented in C++).<br /><br />The challenge to make it work was mostly in adding a few utilities it needed (using Array for "Tuple", setting the top "self" to "MAIN", loading a Type module for coercions, etc) and getting the intialization paths to use the pure-Ruby Hash impl instead of our concrete Java impl. I was able to overcome all these and get Rubinius's hash to function in both compiled and interpreted modes, and run a few simple tests and benchmarks.<br /><br />It is, as you would expect, dozens of times slower than our Java impl, but the performance is better than I expected once the various JIT layers kick in. I doubt it will be possible to get its performance to the same level as hand-written Java code. However, I do believe it's possible to improve performance substantially by enabling some normally unsafe optimizations only for these pure-Ruby kernel classes.<br /><br />I don't expect too many additional challenges loading the other core classes. Obviously we'll need to wire up primitives, but Rubinius's new C++ VM defines them the same way we do in JRuby. Methods in C++ are annotated with information that allows the VM to bind them to the right class and name, just like in JRuby. The only major difference is that Rubinius has a fairly rigid boot sequence I'll mostly be able to fake, since JRuby is already booted by the time the Rubinius kernel loads. My bootloading code to get Hash running was about 10 lines of code, plus some modifications wherever we instantiated our native RubyHash type directly. Basically, JRuby starts up with its own core class impls, then loads the Rubinius kernel to replace them.<br /><br />At any rate, this will probably become a fun side project, since the goal of running the same pure Ruby kernel across many implementations is certainly attractive...even if our kernel is pretty much done already. I'd love to see how fast we can reasonably make Rubinius's kernel run atop the JVM, and the exercise will certainly put JRuby through its paces.<br /><br />I'll push it to an SVN branch later today. Comments and suggestions are welcome :)<br /><br /><span style="font-weight:bold;"><span style="font-style:italic;">Update:</span></span> The branch has been pushed: <a href="http://svn.codehaus.org/jruby/branches/rbx/">http://svn.codehaus.org/jruby/branches/rbx/</a>