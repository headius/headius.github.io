---
layout: post
title: Why Add Syntax When You Have Ruby?
date: '2006-09-28T04:10:00.000-07:00'
author: headius
tags: 
modified_time: '2011-01-25T21:44:33.916-08:00'
blogger_id: tag:blogger.com,1999:blog-4704664917418794835.post-9099049021600914989
blogger_orig_url: http://blog.headius.com/2006/09/why-add-syntax-when-you-have-ruby.html
---

A question came up this morning on the JRuby Users mailing list about a feature Jython and Groovy support: constructors that initialize bean attributes. The example given used a JLabel:<br /><br /><pre>JLabel(text, bounds = bounds, foreground = color)</pre><br />Which ends up being roughly equivalent to:<br /><br /><pre>x = JLabel(text)<br />x.bound = bounds<br />x.foreground = color</pre><br />Groovy has a similar syntax I won't illustrate here. So why doesn't Ruby support this, or perhaps why doesn't JRuby automatically support this syntax for Java types?<br /><br />To answer, let's take a look at what it would take to add this to current Ruby with only existing features.<br /><br />The equivalent syntax in Ruby or JRuby might look like:<br /><br /><pre>SomeClass.new(text, :bounds => bounds, :foreground => foreground)</pre><br />...or possibly using a block as in:<br /><br /><pre>SomeClass.new(text) { @bounds = bounds, @foreground = foreground }</pre><br />However there's no existing accomodation in the semantics of Ruby for these syntax to work out of the box. It would not be hard to write a short bit of code to allow constructing objects in this fashion, of course (using the block approach as an example):<br /><br /><pre>class Class<br /> def construct(*baseargs, &initializer)<br />   x = self.new(*baseargs)<br />   x.instance_eval(&initializer) if initializer<br />   x<br /> end<br />end</pre><br />...which would allow the block example above to work fine (with "construct" in place of "new"). For proxied Java objects, which don't actually have ruby instance vars (@whatever above) it would have to be a slightly different call:<br /><br /><pre>JLabel.construct(text) { self.bounds = bounds, self.foreground =<br />foreground }</pre><br />This works fine, but it's perhaps a little less beautiful. What about this impl instead?<br /><br /><pre>class Class<br /> def construct(*baseargs)<br />   x = self.new(*baseargs)<br />   yield.each_pair { |k,v| x.send("#{k}=", *v) } if block_given?<br />   x<br /> end<br />end</pre><br />Which would allow a variation:<br /><br /><pre>JLabel.construct(text) {{ "{{" }} :bounds => bounds, :foreground =><br />foreground }}</pre><br />(the double {{ "{{" }}}} is intentional; the block returns a hash of initializers)<br /><br />The bottom line is that this kind of syntactic sugar in other languages can easily be added to Ruby through various techniques, and so features like field-initializing constructors don't need to be part of the core language or any of the implementations.<br /><br />Does anyone still wonder why I love this language?